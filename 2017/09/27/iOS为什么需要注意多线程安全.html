<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="前言关于iOS多线程是一个比较炙热的问题的话题。但是在无数了解以及尝试多线程的背后，我觉得还有更重要的一个话题需要被重视，那就是多线程安全。什么叫做不安全，为什么不安全？是一个值得深究的东西。关于多线程的东西以前写过：ios多线程之NSThread,GCD,NSOperation以及线程同步。 一般来说，绝大多数的多线程都是来处理逻辑，计算最终转化为数据。共享状态，多线程共同访问某个对象的prop">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS为什么需要注意多线程安全">
<meta property="og:url" content="http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html">
<meta property="og:site_name" content="BirdMichael">
<meta property="og:description" content="前言关于iOS多线程是一个比较炙热的问题的话题。但是在无数了解以及尝试多线程的背后，我觉得还有更重要的一个话题需要被重视，那就是多线程安全。什么叫做不安全，为什么不安全？是一个值得深究的东西。关于多线程的东西以前写过：ios多线程之NSThread,GCD,NSOperation以及线程同步。 一般来说，绝大多数的多线程都是来处理逻辑，计算最终转化为数据。共享状态，多线程共同访问某个对象的prop">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全/safe00.png">
<meta property="og:updated_time" content="2018-05-29T17:41:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS为什么需要注意多线程安全">
<meta name="twitter:description" content="前言关于iOS多线程是一个比较炙热的问题的话题。但是在无数了解以及尝试多线程的背后，我觉得还有更重要的一个话题需要被重视，那就是多线程安全。什么叫做不安全，为什么不安全？是一个值得深究的东西。关于多线程的东西以前写过：ios多线程之NSThread,GCD,NSOperation以及线程同步。 一般来说，绝大多数的多线程都是来处理逻辑，计算最终转化为数据。共享状态，多线程共同访问某个对象的prop">
<meta name="twitter:image" content="http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全/safe00.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>iOS为什么需要注意多线程安全</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2018/01/29/python学习第一天-python基础操作.html"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2017/09/13/自动引用计数器（ARC）.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href=/ ><i class="fa fa-home" aria-hidden="true" onmouseover="$('#i-home').toggle();" onmouseout="$('#i-home').toggle();"></i></a></li>
      </ul>
      <span id="i-home" class="info" style="display:none;">首 页</span>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&text=iOS为什么需要注意多线程安全"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&title=iOS为什么需要注意多线程安全"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&is_video=false&description=iOS为什么需要注意多线程安全"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=iOS为什么需要注意多线程安全&body=Check out this article: http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&title=iOS为什么需要注意多线程安全"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&title=iOS为什么需要注意多线程安全"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&title=iOS为什么需要注意多线程安全"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&title=iOS为什么需要注意多线程安全"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&name=iOS为什么需要注意多线程安全&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Property"><span class="toc-number">1.1.</span> <span class="toc-text">Property</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Layout"><span class="toc-number">1.2.</span> <span class="toc-text">Memory Layout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不安全的定义"><span class="toc-number">1.3.</span> <span class="toc-text">不安全的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#值类型Property"><span class="toc-number">1.3.1.</span> <span class="toc-text">值类型Property</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针Property"><span class="toc-number">1.3.2.</span> <span class="toc-text">指针Property</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针Property指向的内存区域"><span class="toc-number">1.3.3.</span> <span class="toc-text">指针Property指向的内存区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Property多线程安全小结："><span class="toc-number">1.3.4.</span> <span class="toc-text">Property多线程安全小结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何做到多线程安全？"><span class="toc-number">1.4.</span> <span class="toc-text">如何做到多线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量避免多线程的设计"><span class="toc-number">1.5.</span> <span class="toc-text">尽量避免多线程的设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized"><span class="toc-number">2.</span> <span class="toc-text">@synchronized()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#慎用-synchronized-self"><span class="toc-number">2.1.</span> <span class="toc-text">慎用@synchronized(self)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#精准的粒度控制"><span class="toc-number">2.2.</span> <span class="toc-text">精准的粒度控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意内部的函数调用"><span class="toc-number">2.3.</span> <span class="toc-text">注意内部的函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-mutex"><span class="toc-number">2.4.</span> <span class="toc-text">pthread_mutex</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        iOS为什么需要注意多线程安全
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">BirdMichael</span>
      </span>
      
    <div class="postdate">
        <time datetime="2017-09-26T16:32:09.000Z" itemprop="datePublished">2017-09-27</time>
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于iOS多线程是一个比较炙热的问题的话题。但是在无数了解以及尝试多线程的背后，我觉得还有更重要的一个话题需要被重视，那就是多线程安全。什么叫做不安全，为什么不安全？是一个值得深究的东西。关于多线程的东西以前写过：<a href="http://birdmichael.github.io/2015/07/31/ios-multi-thread-nsthreadgcdnsoperation-and-thread-synchronization/" target="_blank" rel="noopener">ios多线程之NSThread,GCD,NSOperation以及线程同步</a>。</p>
<p>一般来说，绝大多数的多线程都是来处理逻辑，计算最终转化为数据。共享状态，多线程共同访问某个对象的property，在iOS编程里是很普遍的使用场景，我们就从Property的多线程安全说起。</p>
<h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><p>当我们讨论<code>property</code>多线程安全的时候，很多人都知道给<code>property</code>加上<code>atomic attribute</code>之后，可以一定程度的保障多线程安全，类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic, strong) NSString*                 name;</span><br></pre></td></tr></table></figure>
<p>如果你认为这样就一定可以做到多线程安全的话，那你就错了。事实上，情况复杂很多。下面我们来看一下。</p>
<p>如果我们要分析<code>property</code>在多线程场景下的不同表现，首先我们就需要把<code>property</code>的类型做一个区分。</p>
<p>首先，我们把类型区分为大体的两类：值类型、对象。就想我们制定<code>property</code>的<code>attribute</code>一样。值类型一般用<code>assgin</code>修饰，即：<code>int</code>, <code>long</code>, <code>bool</code>等非对象类型。对象类型声明为指针，可以指向某个符合类型定义的内存区域（非值类型的其他类型）。</p>
<p>上面提到的<code>name</code>就是个对象类型，当我们访问<code>name</code>的时候，访问的有可能是<code>name</code>本身，也有可能是<code>name</code>所指向的内存区域。所以这又有一个小的分类。</p>
<p>类型：</p>
<ul>
<li>值类型<ul>
<li>对象类型（本身）</li>
<li>对象类型（只想的内存区域）</li>
</ul>
</li>
</ul>
<p><img src="iOS为什么需要注意多线程安全/safe00.png" alt="safe00"></p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.name = @&quot;birdmichael&quot;;</span><br></pre></td></tr></table></figure>
<p>是在对指针本身进行赋值。而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.userName rangeOfString:@&quot;michael&quot;];</span><br></pre></td></tr></table></figure>
<p>是在访问指针指向的字符串所在的内存区域，这二者并不一样。</p>
<p>分完类之后，我们需要明白这三类property的内存模型。</p>
<h3 id="Memory-Layout"><a href="#Memory-Layout" class="headerlink" title="Memory Layout"></a>Memory Layout</h3><p>当我们讨论多线程安全的时候，其实是在讨论多个线程同时访问一个内存区域的安全问题。针对同一块区域，我们有两种操作，读（load）和写（store），读和写同时发生在同一块区域的时候，就有可能出现多线程不安全。所以展开讨论之前，先要明白上述三种property的内存模型，首先要明白下面的常识：</p>
<p>以64位系统为例，指针<code>NSString*</code>是8个字节的内存区域，<code>int count</code>是个4字节的区域，而<code>@“birdmicahel”</code>是一块根据字符串长度而定的内存区域。</p>
<p>当我们访问property的时候，实际上是访问上图中三块内存区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.name = @&quot;birdmicahel&quot;;</span><br></pre></td></tr></table></figure>
<p>是修改第一块区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.count = 10;</span><br></pre></td></tr></table></figure>
<p>是在修改第二块区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.name rangeOfString:@&quot;michael&quot;];</span><br></pre></td></tr></table></figure>
<p>是在读取第三块区域。</p>
<h3 id="不安全的定义"><a href="#不安全的定义" class="headerlink" title="不安全的定义"></a>不安全的定义</h3><p>明白了property的类型以及他们对应的内存模型，我们再来看看不安全的定义。Wikipedia如是说：</p>
<blockquote>
<p> A piece of code is <strong>thread-safe</strong> if it manipulates shared data structures only in a manner that guarantees safe execution by multiple threads at the same time</p>
</blockquote>
<p>这段定义看起来还是有点抽象，我们可以将多线程不安全解释为：<strong>多线程访问时出现意料之外的结果</strong>。这个意料之外的结果包含几种场景，不一定是指crash，后面再一一分析。</p>
<p>先来看下多线程是如何同时访问内存的。不考虑CPU cache对变量的缓存，内存访问情况：</p>
<p>我们只有一个地址总线，一个内存。即使是在多线程的环境下，也不可能存在两个线程<strong>同时</strong>访问同一块内存区域的场景，内存的访问一定是通过一个地址总线串行排队访问的，所以在继续后续之前，我们先要明确几个结论：</p>
<p><strong>结论一</strong>：内存的访问时串行的，并不会导致内存数据的错乱或者应用的crash。</p>
<p><strong>结论二</strong>：如果读写（load or store）的内存长度小于等于地址总线的长度，那么读写的操作是原子的，一次完成。比如bool，int，long在64位系统下的单次读写都是原子操作。</p>
<p>接下来我们根据上面三种property的分类逐一看下多线程的不安全场景。</p>
<h4 id="值类型Property"><a href="#值类型Property" class="headerlink" title="值类型Property"></a>值类型Property</h4><p>先以BOOL值类型为例，当我们有两个线程访问如下property的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assgin) BOOL    isDeleted;</span><br><span class="line"></span><br><span class="line">//thread 1</span><br><span class="line">bool isDeleted = self.isDeleted;</span><br><span class="line"></span><br><span class="line">//thread 2</span><br><span class="line">self.isDeleted = false;</span><br></pre></td></tr></table></figure>
<p>线程1和线程2，一个读(load)，一个写(store)，对于BOOL isDeleted的访问可能有先后之分，但一定是串行排队的。而且由于BOOL大小只有1个字节，64位系统的地址总线对于读写指令可以支持8个字节的长度，所以对于BOOL的读和写操作我们可以认为是原子的，所以当我们声明BOOL类型的property的时候，从原子性的角度看，使用atomic和nonatomic并没有实际上的区别（当然如果重载了getter方法就另当别论了）。</p>
<p>如果是int类型呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assgin) int    count;</span><br><span class="line"></span><br><span class="line">//thread 1</span><br><span class="line">int curCount = self.count;</span><br><span class="line"></span><br><span class="line">//thread 2</span><br><span class="line">self.count = 1;</span><br></pre></td></tr></table></figure>
<p>同理int类型长度为4字节，读和写都可以通过一个指令完成，所以理论上读和写操作都是原子的。从访问内存的角度看nonatomic和atomic也并没有什么区别。</p>
<p>atomic到底有什么用呢？据我所知，用处有二：</p>
<p><strong>用处一：</strong> <strong>生成原子操作的getter和setter。</strong></p>
<p>设置atomic之后，默认生成的getter和setter方法执行是原子的。也就是说，当我们在线程1执行getter方法的时候（创建调用栈，返回地址，出栈），线程B如果想执行setter方法，必须先等getter方法完成才能执行。举个例子，在32位系统里，如果通过getter返回64位的double，地址总线宽度为32位，从内存当中读取double的时候无法通过原子操作完成，如果不通过atomic加锁，有可能会在读取的中途在其他线程发生setter操作，从而出现异常值。如果出现这种异常值，就发生了<strong>多线程不安全</strong>。</p>
<p><strong>用处二：设置Memory Barrier</strong></p>
<p>对于Objective C的实现来说，几乎所有的加锁操作最后都会设置memory barrier，atomic本质上是对getter，setter加了锁，所以也会设置memory barrier。官方文档表述如下：</p>
<blockquote>
<p><strong>Note:</strong> Most types of locks also incorporate a memory barrier to ensure that any preceding load and store instructions are completed before entering the critical section.</p>
</blockquote>
<p>memory barrier有什么用处呢？</p>
<p>memory barrier能够保证内存操作的顺序，按照我们代码的书写顺序来。听起来有点不可思议，事实是编译器会对我们的代码做优化，在它认为合理的场景改变我们代码最终翻译成的机器指令顺序。也就是说如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.intA = 0;  //line 1</span><br><span class="line">self.intB = 1; //line 2</span><br></pre></td></tr></table></figure>
<p>编译器可能在一些场景下先执行line2，再执行line1，因为它认为A和B之间并不存在依赖关系，虽然在代码执行的时候，在另一个线程intA和intB存在某种依赖，必须要求line1先于line2执行。</p>
<p>如果设置property为atomic，也就是设置了memory barrier之后，就能够保证line1的执行一定是先于line2的，当然这种场景非常罕见，一则是出现变量跨线程访问依赖，二是遇上编译器的优化，两个条件缺一不可。这种极端的场景下，atomic确实可以让我们的代码更加多线程安全一点，但我写iOS代码至今，还未遇到过这种场景，较大的可能性是编译器已经足够聪明，在我们需要的地方设置memory barrier了。</p>
<p><strong>是不是使用了atomic就一定多线程安全呢？</strong>我们可以看看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic, assign)    int       intA;</span><br><span class="line"></span><br><span class="line">//thread A</span><br><span class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">    self.intA = self.intA + 1;</span><br><span class="line">    NSLog(@&quot;Thread A: %d\n&quot;, self.intA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//thread B</span><br><span class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">    self.intA = self.intA + 1;</span><br><span class="line">    NSLog(@&quot;Thread B: %d\n&quot;, self.intA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使我将intA声明为atomic，最后的结果也不一定会是20000。原因就是因为<code>self.intA = self.intA + 1;</code>不是原子操作，虽然intA的getter和setter是原子操作，但当我们使用intA的时候，整个语句并不是原子的，这行赋值的代码至少包含读取(load)，+1(add)，赋值(store)三步操作，当前线程store的时候可能其他线程已经执行了若干次store了，导致最后的值小于预期值。这种场景我们也可以称之为<strong>多线程不安全</strong>。</p>
<h4 id="指针Property"><a href="#指针Property" class="headerlink" title="指针Property"></a>指针Property</h4><p>指针Property一般指向一个对象，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic, strong) NSString*                 name;</span><br></pre></td></tr></table></figure>
<p>无论iOS系统是32位系统还是64位，一个指针的值都能通过一个指令完成load或者store。但和primitive type不同的是，对象类型还有内存管理的相关操作。在MRC时代，系统默认生成的setter类似如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    if(_name != name) &#123;</span><br><span class="line">        [name retain];</span><br><span class="line">        [_name release];</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅仅是赋值操作，还会有retain，release调用。如果property为nonatomic，上述的setter方法就不是原子操作，我们可以假设一种场景，线程1先通过getter获取当前<code>_name</code>，之后线程2通过setter调用<code>[_name release];</code>，线程1所持有的<code>_name</code>就变成无效的地址空间了，如果再给这个地址空间发消息就会导致crash，出现<strong>多线程不安全</strong>的场景。</p>
<p>到了ARC时代，Xcode已经替我们处理了retain和release，绝大部分时候我们都不需要去关心内存的管理，但retain，release其实还是存在于最后运行的代码当中，atomic和nonatomic对于对象类的property声明理论上还是存在差异，不过我在实际使用当中，将NSString*设置为nonatomic也从未遇到过上述多线程不安全的场景，极有可能ARC在内存管理上的优化已经将上述场景处理过了，所以我个人觉得，如果只是对对象类property做read，write，atomic和nonatomic在多线程安全上并没有实际差别。</p>
<h4 id="指针Property指向的内存区域"><a href="#指针Property指向的内存区域" class="headerlink" title="指针Property指向的内存区域"></a>指针Property指向的内存区域</h4><p>这一类多线程的访问场景是我们很容易出错的地方，即使我们声明property为atomic，依然会出错。因为我们访问的不是property的指针区域，而是property所指向的内存区域。可以看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic, strong) NSString*                 stringA;</span><br><span class="line"></span><br><span class="line">//thread A</span><br><span class="line">for (int i = 0; i &lt; 100000; i ++) &#123;</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">        self.stringA = @&quot;a very long string&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        self.stringA = @&quot;string&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;Thread A: %@\n&quot;, self.stringA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//thread B</span><br><span class="line">for (int i = 0; i &lt; 100000; i ++) &#123;</span><br><span class="line">    if (self.stringA.length &gt;= 10) &#123;</span><br><span class="line">        NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;Thread B: %@\n&quot;, self.stringA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然stringA是atomic的property，而且在取substring的时候做了length判断，线程B还是很容易crash，因为在前一刻读length的时候<code>self.stringA = @&quot;a very long string&quot;;</code>，下一刻取substring的时候线程A已经将<code>self.stringA = @&quot;string&quot;;</code>，立即出现out of bounds的Exception，crash，<strong>多线程不安全</strong>。</p>
<p>同样的场景还存在对集合类操作的时候，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic, strong) NSArray*                 arr;</span><br><span class="line"></span><br><span class="line">//thread A</span><br><span class="line">for (int i = 0; i &lt; 100000; i ++) &#123;</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">        self.arr = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        self.arr = @[@&quot;1&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;Thread A: %@\n&quot;, self.arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//thread B</span><br><span class="line">for (int i = 0; i &lt; 100000; i ++) &#123;</span><br><span class="line">    if (self.arr.count &gt;= 2) &#123;</span><br><span class="line">        NSString* str = [self.arr objectAtIndex:1];</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;Thread B: %@\n&quot;, self.arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，即使我们在访问objectAtIndex之前做了count的判断，线程B依旧很容易crash，原因也是由于前后两行代码之间arr所指向的内存区域被其他线程修改了。</p>
<p>所以你看，真正需要操心的是这一类内存区域的访问，即使声明为atomic也没有用，我们平常App出现莫名其妙难以重现的多线程crash多是属于这一类，一旦在多线程的场景下访问这类内存区域的时候，要提起十二分的小心。如何避免这类crash后面会谈到。</p>
<h4 id="Property多线程安全小结："><a href="#Property多线程安全小结：" class="headerlink" title="Property多线程安全小结："></a>Property多线程安全小结：</h4><p>简而言之，atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。</p>
<h3 id="如何做到多线程安全？"><a href="#如何做到多线程安全？" class="headerlink" title="如何做到多线程安全？"></a>如何做到多线程安全？</h3><p>讨论到这里，其实怎么做到多线程安全也比较明朗了，关键字是<strong>atomicity</strong>（原子性），只要做到原子性，小到一个primitive type变量的访问，大到一长段代码逻辑的执行，原子性能保证代码串行的执行，能保证代码执行到一半的时候，不会有另一个线程介入。</p>
<p>原子性是个相对的概念，它所针对的对象，粒度可大可小。</p>
<p>比如下段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (self.stringA.length &gt;= 10) &#123;</span><br><span class="line">    NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是非原子性的。</p>
<p>但加锁以后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//thread A</span><br><span class="line">[_lock lock];</span><br><span class="line">for (int i = 0; i &lt; 100000; i ++) &#123;</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">        self.stringA = @&quot;a very long string&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        self.stringA = @&quot;string&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;Thread A: %@\n&quot;, self.stringA);</span><br><span class="line">&#125;</span><br><span class="line">[_lock unlock];</span><br><span class="line"></span><br><span class="line">//thread B</span><br><span class="line">[_lock lock];</span><br><span class="line">if (self.stringA.length &gt;= 10) &#123;</span><br><span class="line">    NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];</span><br><span class="line">&#125;</span><br><span class="line">[_lock unlock];</span><br></pre></td></tr></table></figure>
<p>整段代码就具有原子性了，就可以认为是多线程安全了。</p>
<p>再比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (self.arr.count &gt;= 2) &#123;</span><br><span class="line">    NSString* str = [self.arr objectAtIndex:1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是非原子性的。</p>
<p>而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//thread A</span><br><span class="line">[_lock lock];</span><br><span class="line">for (int i = 0; i &lt; 100000; i ++) &#123;</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">        self.arr = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        self.arr = @[@&quot;1&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;Thread A: %@\n&quot;, self.arr);</span><br><span class="line">&#125;</span><br><span class="line">[_lock unlock];</span><br><span class="line">    </span><br><span class="line">//thread B</span><br><span class="line">[_lock lock];</span><br><span class="line">if (self.arr.count &gt;= 2) &#123;</span><br><span class="line">    NSString* str = [self.arr objectAtIndex:1];</span><br><span class="line">&#125;</span><br><span class="line">[_lock unlock];</span><br></pre></td></tr></table></figure>
<p>是具有原子性的。注意，<strong>读和写都需要加锁</strong>。</p>
<p>这也是为什么我们在做多线程安全的时候，并不是通过给property加atomic关键字来保障安全，而是将property声明为nonatomic（nonatomic没有getter，setter的锁开销），然后自己加锁。</p>
<p><strong>如何使用哪种锁？</strong></p>
<p>iOS给代码加锁的方式有很多种，常用的有：</p>
<ul>
<li>@synchronized(token)</li>
<li>NSLock</li>
<li>dispatch_semaphore_t</li>
<li>OSSpinLock</li>
</ul>
<p>这几种锁都可以带来原子性，性能的损耗从上至下依次更小。</p>
<p>我个人建议是，在编写应用层代码的时候，除了OSSpinLock之外，哪个顺手用哪个。相较于这几个锁的性能差异，代码逻辑的正确性更为重要。而且这几者之间的性能差异对用户来说，绝大部分时候都感知不到。</p>
<p>当然我们也会遇到少数场景需要追求代码的性能，比如编写framework，或者在多线程读写共享数据频繁的场景，我们需要大致了解锁带来的损耗到底有多少。</p>
<p>官方文档有个数据，使用Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM running OS X v10.5测试，获取mutex有大概0.2ms的损耗，我们可以认为锁带来的损耗大致在ms级别。</p>
<h3 id="尽量避免多线程的设计"><a href="#尽量避免多线程的设计" class="headerlink" title="尽量避免多线程的设计"></a>尽量避免多线程的设计</h3><p>无论我们写过多少代码，都必须要承认多线程安全是个复杂的问题，作为程序员我们应该尽可能的避免多线程的设计，而不是去追求高明的使用锁的技能。</p>
<p>后面我会写一篇文章，介绍函数式编程及其核心思想，即使我们使用非函数式的编程语言，比如Objective C，也能极大的帮助我们避免多线程安全的问题。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized()"></a>@synchronized()</h2><p>@synchronized是几种iOS多线程同步机制中最慢的一个，同时也是最方便的一个。</p>
<p>苹果建立@synchronized的初衷就是方便开发者快速的实现代码同步，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@synchronized(obj) &#123;</span><br><span class="line"></span><br><span class="line">  //code</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了加深理解，我们刨一刨代码看看@synchronized到底做了什么事。我在一个测试工程的main.m中写了一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void testSync()</span><br><span class="line">&#123;</span><br><span class="line">    NSObject* obj = [NSObject new];</span><br><span class="line">    @synchronized (obj) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在源码中一搜，很快就发现了这两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Begin synchronizing on &apos;obj&apos;. </span><br><span class="line">// Allocates recursive mutex associated with &apos;obj&apos; if needed.</span><br><span class="line">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span><br><span class="line">int objc_sync_enter(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // @synchronized(nil) does nothing</span><br><span class="line">        if (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// End synchronizing on &apos;obj&apos;. </span><br><span class="line">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span><br><span class="line">int objc_sync_exit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        if (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bool okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            if (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // @synchronized(nil) does nothing</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述源码中，我们至少可以确立两个信息：</p>
<ul>
<li><strong>synchronized是使用的递归mutex来做同步。</strong></li>
<li><strong>@synchronized(nil)不起任何作用</strong></li>
</ul>
<p>递归mutex的意思是，我们可以写如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (obj) &#123;</span><br><span class="line">    NSLog(@&quot;1st sync&quot;);</span><br><span class="line">    @synchronized (obj) &#123;</span><br><span class="line">        NSLog(@&quot;2nd sync&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不会导致死锁。我顺道扒了下java当中的synchronized关键字，发现也是使用的递归锁，看来这是个common trick。recursive mutex其实里面还是使用了pthread_mutex_t，只不过多了一层ownership的判断，性能上比非递归锁要稍微慢一些。</p>
<p>@synchronized(nil)不起任何作用，表明我们需要适当关注传入的object的声明周期，一旦置为nil之后就无法做代码同步了。</p>
<p><strong>我们再看看传入的obj参数有什么作用</strong>。</p>
<p>继续看代码发现传入的obj被用作参数来获取SyncData对象，里面有一大段关于SyncData的cache逻辑，有兴趣的同学可以自己看下代码，这是一个两层的cache设计，第一层是tls cache，第二层是自己维护的一个hash map。这里将流程简化，来看下obj是如何在hash map中缓存的。</p>
<p>先看下SyncData获取的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyncData **listp = &amp;LIST_FOR_OBJ(object);</span><br></pre></td></tr></table></figure>
<p>而LIST_FOR_OBJ又指向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LIST_FOR_OBJ(obj) sDataLists[obj].data</span><br><span class="line">static StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></table></figure>
<p>再看下StripedMap的实现就很清楚了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static unsigned int indexForPointer(const void *p) &#123;</span><br><span class="line">    uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">    return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">T&amp; operator[] (const void *p) &#123; </span><br><span class="line">    return array[indexForPointer(p)].value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>indexForPointer中使用了obj的内存地址，做了个简单的map，映射到另一个内存空间来存放SyncList。</p>
<p>通过上述分析，我们可以得出结论了：</p>
<p><strong>synchronized中传入的object的内存地址，被用作key，通过hash map对应的一个系统维护的递归锁。</strong></p>
<p>以上就是object的用处，所以不管是传入什么类型的object，只要是有内存地址，就能启动同步代码块的效果。</p>
<p>消化完synchronized的内部实现，我们再来看看平常使用中常见的一些坑。</p>
<h3 id="慎用-synchronized-self"><a href="#慎用-synchronized-self" class="headerlink" title="慎用@synchronized(self)"></a>慎用@synchronized(self)</h3><p>我其实更想说：不要使用@synchronized(self)。</p>
<p>我看过不少代码都是直接将self传入@synchronized当中，这是种很粗糙的使用方式，容易导致死锁的出现。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//class A</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">    [_sharedLock lock];</span><br><span class="line">    NSLog(@&quot;code in class A&quot;);</span><br><span class="line">    [_sharedLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//class B</span><br><span class="line">[_sharedLock lock];</span><br><span class="line">@synchronized (objectA) &#123;</span><br><span class="line">    NSLog(@&quot;code in class B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">[_sharedLock unlock];</span><br></pre></td></tr></table></figure>
<p>原因是因为self很可能会被外部对象访问，被用作key来生成一锁，类似上述代码中的<code>@synchronized (objectA)</code>。两个公共锁交替使用的场景就容易出现死锁。</p>
<p>所以正确的做法是传入一个类内部维护的NSObject对象，而且这个对象是对外不可见的。</p>
<h3 id="精准的粒度控制"><a href="#精准的粒度控制" class="headerlink" title="精准的粒度控制"></a>精准的粒度控制</h3><p>有些人说@synchronized慢，但@synchronized和其他同步锁的性能相比并没有很夸张，对于使用者来说几乎忽略不计。</p>
<p>之所以慢是更多的因为没有做好粒度控制。锁本质上是为了让我们的一段代码获得原子性，不同的critical section要使用不同的锁。我见过很多类似的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (sharedToken) &#123;</span><br><span class="line">    [arrA addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@synchronized (sharedToken) &#123;</span><br><span class="line">    [arrB addObject:obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用同一个token来同步arrA和arrB的访问，虽然arrA和arrB之间没有任何联系。传入self的就更不对了。</p>
<p>应该是不同的数据使用不同的锁，尽量将粒度控制在最细的程度。上述代码应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (tokenA) &#123;</span><br><span class="line">    [arrA addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@synchronized (tokenB) &#123;</span><br><span class="line">    [arrB addObject:obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意内部的函数调用"><a href="#注意内部的函数调用" class="headerlink" title="注意内部的函数调用"></a>注意内部的函数调用</h3><p>@synchronized还有个很容易变慢的场景，就是{}内部有其他隐蔽的函数调用。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (tokenA) &#123;</span><br><span class="line">    [arrA addObject:obj];</span><br><span class="line">    [self doSomethingWithA:arrA];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doSomethingWithA内部可能又调用了其他函数，维护doSomethingWithA的工程师可能并没有意识到自己是被锁同步的，由此层层叠叠可能引入更多的函数调用，代码就莫名其妙的越来越慢了，感觉锁的性能差，其实是我们没用好。</p>
<p>所以在书写@synchronized内部代码的时候，要十分小心内部隐蔽的函数调用。</p>
<h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h3><p>另外再介绍一个个人也觉得超级好用的互斥锁。pthread_mutex只需要初始化一个 pthread_mutex_t 用 pthread_mutex_lock 来锁定 pthread_mutex_unlock 来解锁，当使用完成后，记得调用 pthread_mutex_destroy 来销毁锁。</p>
<p>在配上宏，代码超级美观。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#define Lock() pthread_mutex_lock(&amp;_lock)</span><br><span class="line">#define Unlock() pthread_mutex_unlock(&amp;_lock)</span><br><span class="line"></span><br><span class="line">@implementation </span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">        //lock</span><br><span class="line">        pthread_mutex_init(&amp;_lock, NULL);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doSomething &#123;</span><br><span class="line">    </span><br><span class="line">    Lock();</span><br><span class="line">    // do your stuff</span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">  	pthread_mutex_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Property"><span class="toc-number">1.1.</span> <span class="toc-text">Property</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Layout"><span class="toc-number">1.2.</span> <span class="toc-text">Memory Layout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不安全的定义"><span class="toc-number">1.3.</span> <span class="toc-text">不安全的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#值类型Property"><span class="toc-number">1.3.1.</span> <span class="toc-text">值类型Property</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针Property"><span class="toc-number">1.3.2.</span> <span class="toc-text">指针Property</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针Property指向的内存区域"><span class="toc-number">1.3.3.</span> <span class="toc-text">指针Property指向的内存区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Property多线程安全小结："><span class="toc-number">1.3.4.</span> <span class="toc-text">Property多线程安全小结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何做到多线程安全？"><span class="toc-number">1.4.</span> <span class="toc-text">如何做到多线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量避免多线程的设计"><span class="toc-number">1.5.</span> <span class="toc-text">尽量避免多线程的设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized"><span class="toc-number">2.</span> <span class="toc-text">@synchronized()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#慎用-synchronized-self"><span class="toc-number">2.1.</span> <span class="toc-text">慎用@synchronized(self)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#精准的粒度控制"><span class="toc-number">2.2.</span> <span class="toc-text">精准的粒度控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意内部的函数调用"><span class="toc-number">2.3.</span> <span class="toc-text">注意内部的函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-mutex"><span class="toc-number">2.4.</span> <span class="toc-text">pthread_mutex</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&text=iOS为什么需要注意多线程安全"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&title=iOS为什么需要注意多线程安全"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&is_video=false&description=iOS为什么需要注意多线程安全"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=iOS为什么需要注意多线程安全&body=Check out this article: http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&title=iOS为什么需要注意多线程安全"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&title=iOS为什么需要注意多线程安全"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&title=iOS为什么需要注意多线程安全"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&title=iOS为什么需要注意多线程安全"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2017/09/27/iOS为什么需要注意多线程安全.html&name=iOS为什么需要注意多线程安全&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <li id="home"><a class="icon" href=/><i class="fa fa-list fa-lg" aria-hidden="true"></i> HOME</a></li>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 BirdMichael
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'birdmichael';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


