<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="BirdMichael">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="BirdMichael">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BirdMichael">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>

  <title> BirdMichael </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">BirdMichael</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/28/tableview-due-to-too-many-cell-types-solution/" itemprop="url">
                  在tableView由于cell类型太多解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-28T15:53:39+08:00" content="2015-12-28">
              2015-12-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><pre class="lang:objc decode:true">- (void)configureCellLogical{<br>    // 根绝Modal里面某个值,进行判断应该创建哪个类的cell<br>    [self addCell:@”zhuanti” class:@”BMZhuanTiCell”];<br>    [self addCell:@”tiezi” class:@”BMTieZiCell”];<br>}</pre></p>
<ul>
<li>(void)addCell:(NSString <em>)title class:(NSString </em>)className {<br>  [self.titles addObject:title];<br>  [self.classNames addObject:className];<br>}</li>
</ul>
<p>#pragma mark - Table view data source</p>
<ul>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {<br>  return _titles.count;<br>}</p>
</li>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath {<br>  UITableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:_titles[indexPath.row]];<br>  if (!cell) { // 根据classNames数创建cell/</p>
<pre><code>NSString *className = self.classNames[indexPath.row];
Class class = NSClassFromString(className);
cell = [[class alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:_titles[indexPath.row]];
</code></pre><p>  }<br>  cell.textLabel.text = _titles[indexPath.row];<br>  return cell;<br>}<br>注:代码可能由于是demo,有小的错误,看主要思想即可.</p>
</li>
</ul>
<p>还有一种通常写法,并且很蛋疼的是:</p>
<p><pre class="lang:objc decode:true ">    if (cellType_SecDown == indexPath.section) {<br>        YYOrderSecondDownCell* cell = [tableView dequeueReusableCellWithIdentifier:StringWithCellType(cellType_SecDown)];<br>        if (!cell) {<br>            cell = [[YYOrderSecondDownCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:StringWithCellType(cellType_SecDown)];<br>        }<br>        return cell;<br>    }else if (cellType_DealStatus == indexPath.section){<br>…<br>….</pre><br>于是进入了无限的If else判断..不仅如此,再返回cell,计算高度,点击cell都会进行一次判断.也就是这样的逻辑代码会复制多份,并且如果再任何一个地方修改都需要重新再不同的地方去修改自己的逻辑代码..</p>
<p>&nbsp;</p>
<p>下面贴上抹茶的真实用例,目前没有任何问题,代码也比较美观.性能别以前略有提高</p>
<p>首先是主控制器:</p>
<p><pre class="lang:objc decode:true ">#pragma mark - tableViewDelegate</pre></p>
<ul>
<li>(NSInteger )tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{<br>  // 避免创建tableView时有第一个控制器的数据,导致所有创建出来的tableView都返回第一个tableView的数据<br>  if ([_tabelViews indexOfObject:tableView] != NSNotFound) {<pre><code>NSInteger index = [_tabelViews indexOfObject:tableView];
YYOnlineVC *onlineVCModel = self.onlineVCModels[index];
return onlineVCModel.feedList.count;
</code></pre>  }else{<pre><code>return 0;
</code></pre>  }<br>}</li>
<li>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath{<br>  NSInteger index = [_tabelViews indexOfObject:tableView];<br>  // 1. 取出cell模型<br>  YYOnlineVC </em>onlineVCModel = self.onlineVCModels[index];<br>  NSArray <em>feedList = onlineVCModel.feedList;<br>  // 2. 格式化类名组<br>  NSArray </em>cellClassNames = [YYOnlineBusinessTabHelper formatCellClassArrayWithModelArray:feedList];<br>  // 3. 创建cell<br>  YYOnlineTableViewCell <em>cell = [YYOnlineTableViewCell cellWithTableView:tableView withModalArray:cellClassNames indexpath:indexPath];<br>  // 4. 设置控制器<br>  cell.viewController = self;<br>  // 5. 传递数据<br>  YYOnlinFeed </em>model = feedList[indexPath.row];<br>  [cell updateWithModal:model];<br>  return cell;<br>}</li>
<li>(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath{<br>  NSInteger index = [_tabelViews indexOfObject:tableView];<br>  // 取对应的table模型<br>  YYOnlineVC <em>onlineVCModel = self.onlineVCModels[index];<br>  // 取对应cell 模型<br>  YYOnlinFeed </em>feed = onlineVCModel.feedList[indexPath.row];<br>  // 根据类数组及索引返回高度;<br>  NSString *className = [YYOnlineBusinessTabHelper formatCellClassWithModal:feed];<br>  Class class = NSClassFromString(className);<br>  return [class  heightForModal:feed];<br>}</li>
<li>(void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath{<br>  NSInteger index = [_tabelViews indexOfObject:tableView];<br>  // 取对应的table模型<br>  YYOnlineVC <em>onlineVCModel = self.onlineVCModels[index];<br>  // 取对应cell 模型<br>  YYOnlinFeed </em>feed = onlineVCModel.feedList[indexPath.row];<br>  //下面是具体的跳转<br>  ….<br>}<blockquote>
<p>这个页面的情况是:有多个tableview,所以索引是感觉tableView在tableView数组中取到索引,然后根据索引再模型数组中取到具体的模型..正常tableView可以省略这部.<br>下面是<span class="s1">YYOnlineBusinessTabHelper,是页面的VM层</span><br><pre class="lang:objc decode:true ">+ (NSArray <em>)formatCellClassArrayWithModelArray:(NSArray </em>)modelArray{<br>  NSMutableArray <em>classArray = [@[] mutableCopy];<br>  for (YYOnlinFeed </em>feed in modelArray) {</pre></p>
<pre><code>if (feed.dataType.integerValue == 1) {
    // 商品
    [classArray addObject:@&quot;YYOnlineGoodsCell&quot;];
}else if (feed.dataType.integerValue == 2){
    // 专题
    [classArray addObject:@&quot;YYOnlineSubjectCell&quot;];
}
</code></pre><p>  }<br>  return classArray;<br>}</p>
</blockquote>
</li>
</ul>
<ul>
<li>(NSString <em>)formatCellClassWithModal:(YYOnlinFeed </em>)feed{<br>  if (feed.dataType.integerValue == 1) {<pre><code>// 商品
return @&quot;YYOnlineGoodsCell&quot;;
</code></pre>  }else if (feed.dataType.integerValue == 2){<pre><code>// 专题
return @&quot;YYOnlineSubjectCell&quot;;
</code></pre>  }<br>  return @”YYOnlineSubjectCell”;<br>}<blockquote>
<p>这样做的好处是:1.可以减少并且统一控制器的逻辑控制层,以后需要添加其他的cell类型,修改对应cell只需要在这一个地方修改,全控制器通用.</p>
<p>小提示:ClassArray请务必采用复制粘贴的方式,避免错误.<br>下面是主tableViewCell</p>
</blockquote>
</li>
</ul>
<p>.h</p>
<p><pre class="lang:objc decode:true ">#import &lt;UIKit/UIKit.h&gt;<br>@class YYOnlinFeed;<br>@interface YYOnlineTableViewCell : UITableViewCell<br>@property (nonatomic ,strong) YYOnlinFeed * feedModel;<br>@property (nonatomic ,weak)id viewController;</pre></p>
<ul>
<li>(instancetype)cellWithTableView:(UITableView <em>)tableView withModalArray:(NSArray </em>)classNames indexpath:(NSIndexPath *)indexPath;</li>
</ul>
<ul>
<li>(void)updateWithModal:(YYOnlinFeed *)feedModel;</li>
</ul>
<ul>
<li>(CGFloat)heightForModal:(YYOnlinFeed *)feedModel;<br>@end<br>.m<br><pre class="lang:objc decode:true ">//<br>//  YYOnlineTableViewCell.m<br>//  mocha<br>//<br>//  Created by BM on 16/1/6.<br>//  Copyright © 2016年 Yao. All rights reserved.<br>//</pre></li>
</ul>
<p>#import “YYOnlineTableViewCell.h”</p>
<p>@implementation YYOnlineTableViewCell</p>
<ul>
<li><p>(instancetype)cellWithTableView:(UITableView <em>)tableView withModalArray:(NSArray </em>)classNames indexpath:(NSIndexPath <em>)indexPath<br>{<br>  YYOnlineTableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:classNames[indexPath.row]];<br>  if (!cell) {</p>
<pre><code>// 根据classNames数创建cell/
NSString *className = classNames[indexPath.row];
Class class = NSClassFromString(className);
cell = [[class alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:classNames[indexPath.row]];
</code></pre><p>  }</p>
<p>  // code..<br>  return cell;<br>}</p>
</li>
</ul>
<ul>
<li>(void)updateWithModal:(YYOnlinFeed *)feedModel{<br>  NSLog(@”YYOnlineTableViewCell:请在子类重写 updateWithModal方法”);<br>}</li>
</ul>
<ul>
<li>(CGFloat)heightForModal:(YYOnlinFeed *)feedModel{<br>  NSLog(@”YYOnlineTableViewCell:请在子类重写 heightForModal方法”);<br>  return 30;<br>}<br>具体需要显示的具体cell只需要继承主cell并且重写<span class="s1">updateWithModal和</span><span class="s1">heightForModal.</span><blockquote>
<p>大概的逻辑如此,这里我知道的</p>
<p>缺点:</p>
<p>1.会多引入一个ClassArray数组来存储具体的cell类名</p>
<p>优点:</p>
<p>1.逻辑判断集中在一个地方,以便于以后的更改.</p>
<p>2.主控制器逻辑代码简洁,每一句都是一个主要逻辑,不臃肿.</p>
<p>3.不需要在数据源3次调用,代码最少1次都重复去写If判断<br>还有一种方式是通过协议,不过我还没有实践过.</p>
</blockquote>
</li>
</ul>
<p>&nbsp;</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/22/code-code-organization/" itemprop="url">
                  代码规范一:Code Organization
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-22T17:02:02+08:00" content="2015-12-22">
              2015-12-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一般,使用#pragma mark 来模块化代码,以下是一个比较通用的结构.</p>
<p><pre class="lang:objc decode:true ">#pragma mark - Lifecycle</pre></p>
<ul>
<li>(instancetype)init {}</li>
<li>(void)dealloc {}</li>
<li>(void)viewDidLoad {}</li>
<li>(void)viewWillAppear:(BOOL)animated {}</li>
<li>(void)didReceiveMemoryWarning {}</li>
</ul>
<p>#pragma mark - Custom Accessors</p>
<ul>
<li>(void)setCustomProperty:(id)value {}</li>
<li>(id)customProperty {}</li>
</ul>
<p>#pragma mark - IBActions</p>
<ul>
<li>(IBAction)submitData:(id)sender {}</li>
</ul>
<p>#pragma mark - Public</p>
<ul>
<li>(void)publicMethod {}</li>
</ul>
<p>#pragma mark - Private</p>
<ul>
<li>(void)privateMethod {}</li>
</ul>
<p>#pragma mark - Protocol conformance</p>
<p>#pragma mark - UITextFieldDelegate</p>
<p>#pragma mark - UITableViewDataSource</p>
<p>#pragma mark - UITableViewDelegate</p>
<p>#pragma mark - NSCopying</p>
<ul>
<li>(id)copyWithZone:(NSZone *)zone {}</li>
</ul>
<p>#pragma mark - NSObject</p>
<ul>
<li>(NSString *)description {}<br>&nbsp;</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/07/e8-b0-88-e8-b0-88uiview-e7-9a-84-e5-87-a0-e4-b8-aalayout-e6-96-b9-e6-b3-95-layoutsubviews-e3-80-81layoutifneeded-e3-80-81setneedslayout/" itemprop="url">
                  谈谈UIView的几个layout方法-layoutSubviews、layoutIfNeeded、setNeedsLayout...
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-07T22:58:48+08:00" content="2015-12-07">
              2015-12-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下面列举下iOS layout的相关方法:</p>
<ul>
<li>layoutSubviews</li>
<li>layoutIfNeeded</li>
<li>setNeedsLayout</li>
<li>setNeedsDisplay</li>
<li>drawRect</li>
<li>sizeThatFits</li>
<li>sizeToFit<br>大概常用的上面几个 ， 具体的应该还有别的。</li>
</ul>
<h4 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews"></a>layoutSubviews</h4><p>这个方法，默认没有做任何事情，需要子类进行重写 。 系统在很多时候会去调用这个方法：</p>
<p>1.初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发。<br>2.addSubview会触发layoutSubviews<br>3.设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化<br>4.滚动一个UIScrollView会触发layoutSubviews<br>5.旋转Screen会触发父UIView上的layoutSubviews事件<br>6.改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</p>
<blockquote>
<p>在苹果的官方文档中强调: You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。</p>
</blockquote>
<h4 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout"></a>setNeedsLayout</h4><p>标记为需要重新布局，不立即刷新，但layoutSubviews一定会被调用<br>配合layoutIfNeeded立即更新</p>
<h4 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded"></a>layoutIfNeeded</h4><p>如果，有需要刷新的标记，立即调用layoutSubviews进行布局</p>
<p>这个动画中有用到 举个栗子&#x1f330; 。</p>
<p><div><img src="http://upload-images.jianshu.io/upload_images/954071-43b26489414f3d01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></div><br>如图 ， 上面有个label ，中间有个按钮 ， label已经被自动布局到左上角 。 然后我们那个left的constraint</p>
<p><pre>  @IBOutlet weak var leftContrain:NSLayoutConstraint!</pre><br>在viewDidLoad中声明好，然后在Main.storyboard中进行连线。点击按钮的时候 ，我们把左边的距离改成100 。</p>
<p>在按钮的点击事件里加上这句。</p>
<p><pre>leftContrain.constant = 100</pre><br>然后我们想要一个动画的效果。<br>如果这么做</p>
<p><pre>   UIView.animateWithDuration(0.8, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: UIViewAnimationOptions.AllowAnimatedContent, animations: {<br>                self.leftContrain.constant = 100<br>            }, completion: nil)</pre><br>你会发现然并卵 。其实这句话self.leftContrain.constant = 100只是执行了setNeedsLayout 标记了需要重新布局，但是没有立即执行。所以我们需要在动画中调用这个方法layoutIfNeeded<br>所以代码应该这么写</p>
<p><pre>leftContrain.constant = 100<br>        UIView.animateWithDuration(0.8, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: UIViewAnimationOptions.AllowAnimatedContent, animations: {<br>                self.view.layoutIfNeeded() //立即实现布局<br>            }, completion: nil)</pre><br>所以上面不管写多少约束的改变，只需要在动画里动用 一次self.view.layoutIfNeeded(),所有的都会已动画的方式 。如果一些变化不想动画 。在动画前执行self.view.layoutIfNeeded()</p>
<h3 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h3><p>这个方法是用来重绘的。</p>
<p>drawRect在以下情况下会被调用：<br>1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).<br>2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。以上1,2推荐；而3,4不提倡</p>
<p>drawRect方法使用注意点：<br>1、若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。2、若使用calayer绘图，只能在drawInContext: 中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</p>
<h3 id="sizeToFit"><a href="#sizeToFit" class="headerlink" title="sizeToFit"></a>sizeToFit</h3><ul>
<li>sizeToFit会自动调用sizeThatFits方法；</li>
<li>sizeToFit不应该在子类中被重写，应该重写sizeThatFits</li>
<li>sizeThatFits传入的参数是receiver当前的size，返回一个适合的size</li>
<li>sizeToFit可以被手动直接调用sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/12/ios-application-architecture/" itemprop="url">
                  iOS中应用的架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-12T20:14:43+08:00" content="2015-11-12">
              2015-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/摘。/" itemprop="url" rel="index">
                    <span itemprop="name">摘。</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>&nbsp;</p>
<p>本人尤其的钟爱iOS中得架构技术,本人以摘抄方式记录并学习,原文作者田伟宇大神,<a href="http://casatwy.com" target="_blank" rel="external">http://casatwy.com</a>.</p>
<p>其实对于iOS客户端应用的架构来说，复杂度不亚于服务端，但侧重点和入手点却跟服务端不太一样。比如客户端应用就不需要考虑类似C10K的问题，正常的app就根本不需要考虑。</p>
<p>这系列文章作者主要专注在iOS应用架构方面，很多方案也是基于iOS技术栈的特点而建立的。如果你是Android开发者，你可以侧重看我提出的一些架构思想，毕竟不管做什么，思路是相通的，实现手段不同罢了。</p>
<h1 id="客户端应用架构？"><a href="#客户端应用架构？" class="headerlink" title="客户端应用架构？"></a>客户端应用架构？</h1><p>其实市面上大部分应用不外乎就是颠过来倒过去地做以下这些事情：</p>
<div><br><pre class="lang:objc decode:true">    —————     —————     —————     —————<br>    |             |     |             |     |             |     |             |<br>    | 调用网络API  | –&gt; |   展现列表    | –&gt; |  选择列表    | –&gt; |   展现单页   |<br>    |             |     |             |     |             |     |             |<br>    —————     —————     —————     —————<br>                               ^                                        |<br>                               |                                        |<br>                               |                                        |<br>                               ——————————————</pre><br></div><br>所以现在的APP步骤其实: 请求&gt;展示对应数据|&gt;跳转其他控制器&gt;请求&gt;展示对应数据.<br><br>## 那这特么有毛好架构的？<br><br>&gt; 非也，非也。 —- 包不同 《天龙八部》<br>App确实就是主要做这些事情，但是支撑这些事情的基础，就是做架构要考虑的事情。<br><br><em>   调用网络API
</em>   页面展示<br><em>   数据的本地持久化
</em>   动态部署方案<br>上面这四大点，也就是我们通常所说的：<br><br><em>   如何让业务开发工程师方便安全地调用网络API？然后尽可能保证用户在各种网络环境下都能有良好的体验？
</em>   页面如何组织，才能尽可能降低业务方代码的耦合度？尽可能降低业务方开发界面的复杂度，提高他们的效率？<br><em>   当数据有在本地存取的需求的时候，如何能够保证数据在本地的合理安排？如何尽可能地减小性能消耗？
</em>   iOS应用有审核周期，如何能够通过不发版本的方式展示新的内容给用户？如何修复紧急bug？<br>&gt; 其中”调用网络API”和”页面展示”是现在百分之九十的客户端都已经再涉猎或者说已经做得相对比较好了,而在”数据的本地持久化”和”动态部署方案”现在现在的客户端都选择了自动忽视.尤其是再动态部署方案上,很多东西对新内容的选择方式就是重新发版,但是众所周知的iOS的审核周期非常的蛋疼.<br>上面几点是针对App说的，下面还有一些是针对团队说的：<br><br><em>   收集用户数据，给产品和运营提供参考
</em>   合理地组织各业务方开发的业务模块，以及相关基础模块<br><em>   每日app的自动打包，提供给QA工程师的测试工具<br>一时半会儿我还是只能想到上面这三点，事实上应该还会有很多，想不起来了。<br><br>所以当我们讨论客户端应用架构的时候，我们讨论的差不多就是这些问题。<br><br># 这系列文章要回答那些问题？<br><br>这系列文章主要是回答以下这些问题：<br><br>1.  网络层设计方案？设计网络层时要考虑哪些问题？对网络层做优化的时候，可以从哪些地方入手？<br>2.  页面的展示、调用和组织都有哪些设计方案？我们做这些方案的时候都要考虑哪些问题？<br>3.  本地持久化层的设计方案都有哪些？优劣势都是什么？不同方案间要注意的问题分别都是什么？<br>4.  要实现动态部署，都有哪些方案？不同方案之间的优劣点，他们的侧重点？<br><br># 本文要回答那些问题？<br><br>上面细分出来的四个问题，我会分别在四篇文章里面写。那么这篇文章就是来讲一些通识啥的，也是开个坑给大家讨论通识问题的。<br><br># 架构设计的方法<br><br>所有事情最难的时候都是开始做的时候，当你开始着手设计并实现某一层的架构乃至整个app的架构的时候，很有可能会出现暂时的无从下手的情况。以下方法论是我这些年总结出来的经验，每个架构师也一定都有一套自己的方法论，但一样的是，不管你采用什么方法，全局观、高度的代码审美能力、灵活使用各种设计模式一定都是贯穿其中的。欢迎各位在评论区讨论。<br><br>## 第一步<br><br>搞清楚要解决哪些问题，并找到解决这些问题的充要条件<br><br>你必须得清楚你要做什么，业务方希望要什么。而不是为了架构而架构，也不是为了体验新技术而改架构方案。以前是MVC，最近流行MVVM，如果过去的MVC是个好架构，没什么特别大的缺陷，就不要推倒然后搞成MVVM。<br><br>关于充要条件我也要说明一下，有的时候系统提供的函数是需要额外参数的，比如read函数。还有翻页的时候，当前页码也是充要条件。但对于业务方来说，这些充要条件还能够再缩减。<br><br>比如read，需要给出file descriptor，需要给出buf，需要给出size。但是对于业务方来说，充要条件就只要file descriptor就够了。再比如翻页，其实业务方并不需要记录当前页号，你给他暴露一个loadNextPage这样的方法就够了。<br><br>搞清楚对于业务方而言的真正充要条件很重要！这决定了你的架构是否足够易用。另外，传的参数越少，耦合度相对而言就越小，你替换模块或者升级模块所花的的代价就越小。<br><br>## 第二步<br><br>问题分类，分模块<br><br>这个不用多说了吧。<br><br>## 第三步<br><br>搞清楚各问题之间的依赖关系，建立好模块交流规范并设计模块<br><br>关键在于建立一套统一的交流规范。这一步很能够体现架构师在软件方面的价值观，虽然存在一定程度上的好坏优劣（比如胖Model和瘦Model），但既然都是架构师了，基本上是不会设计出明显很烂的方案的，除非这架构师还不够格。所以这里是架构师价值观输出的一个窗口，从这一点我们是能够看出架构师的素质的。<br><br>另外要注意的是，一定是建立一套统一的交流规范，不是两套，不是多套。你要坚持你的价值观，不要摇摆不定。要是搞出各种五花八门的规范出来，一方面有不切实际的炫技嫌疑，另一方面也会带来后续维护的灾难。<br><br>## 第四步<br><br>推演预测一下未来可能的走向，必要时添加新的模块，记录更多的基础数据以备未来之需<br><br>很多称职的架构师都会在这时候考虑架构未来的走向，以及考虑做完这一轮架构之后，接下来要做的事情。一个好的架构虽然是功在当代利在千秋的工程，但绝对不是一个一劳永逸的工程。软件是有生命的，你做出来的架构决定了这个软件它这一生是坎坷还是幸福。<br><br>## 第五步<br><br>先解决依赖关系中最基础的问题，实现基础模块，然后再用基础模块堆叠出整个架构<br><br>这一步也是验证你之前的设计是否合理的一步，随着这一步的推进，你很有可能会遇到需要对架构进行调整的情况。这个阶段一定要吹毛求疵高度负责地去开发，不要得过且过，发现架构有问题就及时调整。否则以后调整的成本就非常之大了。<br><br>第六步<br><br>打点，跑单元测试，跑性能测试，根据数据去优化对应的地方<br><br>你得用这些数据去向你的boss邀功，你也得用这些数据去不断调整你的架构。<br><br>总而言之就是要遵循这些原则：自顶向下设计（1，2，3，4步），自底向上实现（5），先测量，后优化（6）。<br><br># 什么样的架构师是好架构师？

</em>   每天都在学习，新技术新思想上手速度快，理解速度快<br>做不到这点，你就是码农<br><br><em>   业务出身，或者至少非常熟悉公司所处行业或者本公司的业务<br>做不到这点，你就是运维

</em>   熟悉软件工程的各种规范，踩过无数坑。不会为了完成需求不择手段，不推崇quick &amp; dirty<br>做不到这点，你比较适合去竞争对手那儿当工程师<br><br><em>   及时承认错误，不要觉得承认错误会有损你架构师的身份<br>做不到这点，公关行业比较适合你

</em>   不为了炫技而炫技<br>做不到这点，你就是高中编程爱好者<br><br><em>   精益求精<br>做不到这点，（我想了好久，但我还是不知道你适合去干什么。）<br><br># 什么样的架构叫好架构？<br><br>1.  代码整齐，分类明确，没有common，没有core<br>2.  不用文档，或很少文档，就能让业务方上手<br>3.  思路和方法要统一，尽量不要多元<br>4.  没有横向依赖，万不得已不出现跨层访问<br>5.  对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件<br>6.  易测试，易拓展<br>7.  保持一定量的超前性<br>8.  接口少，接口参数少<br>9.  高性能<br>以上是我判断一个架构是不是好架构的标准，这是根据重要性来排列的。客户端架构跟服务端架构要考虑的问题和侧重点是有一些区别的。下面我会针对每一点详细讲解一下：

</em>   代码整齐，分类明确，没有common，没有core<br>代码整齐是每一个工程师的基本素质，先不说你搞定这个问题的方案有多好，解决速度有多快，如果代码不整齐，一切都白搭。因为你的代码是要给别人看的，你自己也要看。如果哪一天架构有修改，正好改到这个地方，你很容易自己都看不懂。另外，破窗理论提醒我们，如果代码不整齐分类不明确，整个架构会随着一次一次的拓展而越来越混乱。<br><br>分类明确的字面意思大家一定都了解，但还有一个另外的意思，那就是：不要让一个类或者一个模块做两种不同的事情。如果有类或某模块做了两种不同的事情，一方面不适合未来拓展，另一方面也会造成分类困难。<br><br>不要搞Common，Core这些东西。每家公司的架构代码库里面，最恶心的一定是这两个名字命名的文件夹，我这么说一定不会错。不要开Common，Core这样的文件夹，开了之后后来者一定会把这个地方搞得一团糟，最终变成Common也不Common，Core也不Core。要记住，架构是不断成长的，是会不断变化的。不是每次成长每次变化，都是由你去实现的。如果真有什么东西特别小，那就索性为了他单独开辟一个模块就好了，小就小点，关键是要有序。<br><br>一般情况下，我们都会有一些属于这个项目的公共类，比如取定位坐标，比如图像处理。这些模块可能非常小，就h和m两个文件。单独拎出来成为一个模块感觉不够格，但是又不属于其他任何一个模块。于是大家很有可能就会把它们放入Common里面，我目前见到的大多数工程和大多数文档里面的代码都喜欢这么做。在当时来看，这么做看不出什么问题，但关键在于：软件是有生命，会成长的。当时分出来的小模块，很有可能会随着业务的成长，逐渐发展成大模块，发展成大模块后，可以再把它从Common移出来单独成立一个模块。这个在理论上是没有任何问题的，然而在实际操作过程中，工程师在拓张这个小模块的时候，不太容易会去考虑横向依赖的问题，因为当时这些模块都在Common里面，直接进行互相依赖是非常符合直觉的，而且也不算是不遵守规范。然而要注意的是，这才是Commom代码混乱的罪魁祸首，Common文件夹纵容了不精心管理依赖的做法。当Common里面的模块依赖关系变得复杂，再想要移出来单独成立一个模块，就不是当初设置Common时想的等规模大了再移除也不迟那么简单了。<br>&gt; 另外，Common有的时候也不仅仅是一个文件夹。<br>在使用Cocoapods来管理项目库的时候，Common往往就是一个pod。这个pod里面会有A/B/C/D/E这些函数集或小模块。如果要新开一个app或者Demo，势必会使用到Common这个pod，这么做，往往会把不需要包含的代码也包含进去，我对项目有高度洁癖，这种情况会让我觉得非常不舒服。<br><br><em> </em> <em><br><br>举个例子：早年安居客的app还不是集齐所有新房、二手房、租房业务的。当你刚开始写新房这个app的时候，创建了一个Common这个pod，这里面包含了一些对于新房来说比较Common的代码，也包含了对于这个app来说比较Common的代码。过了半年或者一年，你要开始二手房这个app，我觉得大多数人都会选择让二手房也包含这个Common，于是这个Common很有可能自己走上另一条发展的道路。等到了租房这个业务要开app的时候，Common已经非常之庞大，相信这时候的你也不会去想整理Common的事情了，先把租房搞定，于是Common最终就变成了一坨屎。<br><br>就对于上面的例子来说，还有一个要考虑的是，分出来的三个业务很有可能会有三个Common，假设三个Common里面都有公共的功能，交给了三个团队去打理，如果遇到某个子模块需要升级，那么三个Common里面的这个子模块都要去同步升级，这是个很不效率的事情。另外，很有可能三个Common到最后发展成彼此不兼容，但是代码相似度非常之高，这个在架构上，是属于分类条理不清。<br><br>就在去年年中的时候，安居客决定将三个业务归并到同一个App。好了，如果你是架构师，面对这三个Common，你打算怎么办？要想最快出成果，那就只好忍受代码冗余，赶紧先把架子搭起来再说，否则你面对的就是剪不断理还乱的Common。此时Common就已经很无奈地变成一坨屎了。这样的Common，你自己说不定也搞不清楚它里面到底都有些什么了，交给任何一个人去打理，他都不敢做彻底的整理的。

</em> <em> </em><br><br>还有就是，Common本身就是一个粒度非常大的模块。在阿里这样大规模的团队中，即便新开一个业务，都需要在整个app的环境下开发，为什么？因为模块拆分粒度不够，要想开一个新业务，必须把其他业务的代码以及依赖全部拉下来，然后再开新入口，你的新业务才能进行正常的代码编写和调试。然而你的新业务其实只依赖首页入口、网络库等这几个小模块，不需要依赖其他那么多的跟你没关系的业务。现在每次打开天猫的项目，我都要等个两三分钟，这非常之蛋疼。<br><br>但是大家真的不知道这个原因吗？知道了这个原因，为什么没人去把这些粒度不够细的模块整理好？在我看来，这件事没人敢做。<br><br>1.  原来大家用的好好的，手段烂就烂一点，你改了你能保证不出错？<br>2.  这么复杂的东西，短期之内你肯定搞不好，任务量和工时都不好估，你leader会觉得你在骗工时玩自己的事情。<br>3.  就算你搞定了，QA这边肯定再需要做一次全面的回归测试，任务量极大，难以说服他们配合你的工作。<br>花这么大的成本只是为了减少开启项目时候等待IDE打开时的那几分钟时间？我想如果我是你leader，我也应该不会批准你做这样的事情的。所以，与其到了后面吃这个苦头，不如一开始做架构的时候就不要设置Common，到后面就能省力很多。架构师的工作为什么是功在当代利在千秋，架构师的素质为什么对团队这么重要？我觉得这里就是一个最好的体现。<br><br><em> </em> <em><br><br>简而言之，不建议开Common的原因如下：<br><br>1.  Common不仅仅是一个文件夹，它也会是一个Pod。不管是什么，在Common里面很容易形成错综复杂的小模块依赖，在模块成长过程中，会纵容工程师不注意依赖的管理，乃至于将来如果要将模块拆分出去，会非常的困难。<br>2.  Common本身与细粒度模块设计的思想背道而驰，属于一种不合适的偷懒手段，在将来业务拓张会成为阻碍。<br>3.  一旦设置了Common，就等于给地狱之门打开了一个小缝，每次业务迭代都会有一些不太好分类的东西放入Common，这就给维护Common的人带来了非常大的工作量，而且这些工作量全都是体力活，非常容易出错。<br>&gt; 那么，不设Common会带来哪些好处？<br><br>1.  强迫工程师在业务拓张的时候将依赖管理的事情考虑进去，让模块在一开始发展的时候就有自己的土壤，成长空间和灵活度非常大。<br>2.  减少各业务模块或者Demo的体积，不需要的模块不会由于Common的存在而包含在内。<br>3.  可维护性大大提高，模块升级之后要做的同步工作非常轻松，解放了那个苦逼的Common维护者，更多的时间可以用在更实质的开发工作上。<br>4.  符合细粒度模块划分的架构思想。<br>Common的好处只有一个，就是前期特别省事儿。然而它的坏处比好处要多太多。不设置Common，再小的模块再小的代码也单独拎出来，最多就是Podfile里面要多写几行，多写几行最多只花费几分钟。但若要消除Common所带来的罪孽，不是这几分钟就能搞定的事情。既然不用Common的好处这么多，那何乐而不为呢？<br><br>假设将来你的项目中有一个类是用来做Location的，哪怕只有两个文件，也给他开一个模块就叫Location。如果你的项目中有一个类是用来做ImageProcess的，那也开一个模块就叫ImageProcess。不要都放到Common里面去，将来你再开新的项目或者新的业务，用Location就写依赖Location，用ImageProcess就写依赖ImageProcess，不要再依赖Common了，这样你的项目也好管理，管理Common的那个人日子过得也轻松（这个人其实都可以不需要了，把他的工资加到你头上不是更好？:D），将来要升级，顾虑也少。

</em>   不用文档，或很少文档，就能让业务方上手<br>谁特么会去看文档啊，业务方他们已经被产品经理逼得很忙了。所以你要尽可能让你的API名字可读性强，对于iOS来说，objc这门语言的特性把这个做到了极致，函数名长就长一点，不要紧。<br><div><br><pre class="">好的函数名：<br>    - (NSDictionary <em>)exifDataOfImage:(UIImage </em>)image atIndexPath:(NSIndexPath <em>)indexPath;<br><br>坏的函数名：<br>    - (id)exifData:(UIImage </em>)image position:(id)indexPath callback:(id&lt;ErrorDelegate&gt;)delegate;<br><br>为什么坏？<br>    1. 不要直接返回id或者传入id，实在不行，用id&lt;protocol&gt;也比id好。如果连这个都做不到，你要好好考虑你的架构是不是有问题。<br>    2. 要告知业务方要传的东西是什么，比如要传Image，那就写上ofImage。如果要传位置，那就要写上IndexPath，而不是用position这么笼统的东西<br>    3. 没有任何理由要把delegate作为参数传进去，一定不会有任何情况不得不这么做的。而且delegate这个参数根本不是这个函数要解决的问题的充要条件，如果你发现你不得不这么做，那一定是架构有问题！</pre><br></div>

<ul>
<li>思路和方法要统一，尽量不要多元<br>解决一个问题会有很多种方案，但是一旦确定了一种方案，就不要在另一个地方采用别的方案了。也就是做架构的时候，你得时刻记住当初你决定要处理这样类型的问题的方案是什么，以及你的初衷是什么，不要摇摆不定。</li>
</ul>
<p>另外，你当初设立这个模块一定是有想法有原因的，要记录下你的解决思路，不要到时候换个地方你又灵光一现啥的，引入了其他方案，从而导致异构。</p>
<p>要是一个框架里面解决同一种类似的问题有各种五花八门的方法或者类，我觉得做这个架构的架构师一定是自己都没想清楚就开始搞了。</p>
<ul>
<li>没有横向依赖，万不得已不出现跨层访问<br>没有横向依赖是很重要的，这决定了你将来要对这个架构做修补所需要的成本有多大。要做到没有横向依赖，这是很考验架构师的模块分类能力和是否熟悉业务的。</li>
</ul>
<p>跨层访问是指数据流向了跟自己没有对接关系的模块。有的时候跨层访问是不可避免的，比如网络底层里面信号从2G变成了3G变成了4G，这是有可能需要跨层通知到View的。但这种情况不多，一旦出现就要想尽一切办法在本层搞定或者交给上层或者下层搞定，尽量不要出现跨层的情况。跨层访问同样也会增加耦合度，当某一层需要整体替换的时候，牵涉面就会很大。</p>
<ul>
<li>对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件<br>把这点做好，很依赖于架构师的经验。架构师必须要有能力区分哪些情况需要限制灵活性，哪些情况需要创造灵活性。比如对于Core Data技术栈来说，ManagedObject理论上是可以出现在任何地方的，那就意味着任何地方都可以修改ManagedObject，这就导致ManagedObjectContext在同步修改的时候把各种不同来源的修改同步进去。这时候就需要限制灵活性，只对外公开一个修改接口，不暴露任何ManagedObject在外面。</li>
</ul>
<p>如果是设计一个ABTest相关的API的时候，我们又希望增加它的灵活性。使得业务方不光可以通过Target-Action的模式实现ABtest，也要可以通过Block的方式实现ABTest，要尽可能满足灵活性，减少业务方的使用成本。</p>
<ul>
<li><p>易测试易拓展<br>老生常谈，要实现易测试易拓展，那就要提高模块化程度，尽可能减少依赖关系，便于mock。另外，如果是高度模块化的架构，拓展起来将会是一件非常容易的事情。</p>
</li>
<li><p>保持一定量的超前性<br>这一点能看出架构师是否关注行业动态，是否能准确把握技术走向。保持适度的技术上的超前性，能够使得你的架构更新变得相对轻松。</p>
</li>
</ul>
<p>另外，这里的超前性也不光是技术上的，还有产品上的。谁说架构师就不需要跟产品经理打交道了，没事多跟产品经理聊聊天，听听他对产品未来走向的畅想，你就可以在合理的地方为他的畅想留一条路子。同时，在创业公司的环境下，很多产品需求其实只是为了赶产品进度而产生的妥协方案，最后还是会转到正轨的。这时候业务方可以不实现转到正规的方案，但是架构这边，是一定要为这种可预知的改变做准备的。</p>
<ul>
<li><p>接口少，接口参数少<br>越少的接口越少的参数，就能越降低业务方的使用成本。当然，充要条件还是要满足的，如何在满足充要条件的情况下尽可能地减少接口和参数数量，这就能看出架构师的功力有多深厚了。</p>
</li>
<li><p>高性能<br>为什么高性能排在最后一位？</p>
</li>
</ul>
<p>高性能非常重要，但是在客户端架构中，它不是第一考虑因素。原因有下：</p>
<ul>
<li>客户端业务变化非常之快，做架构时首要考虑因素应当是便于业务方快速满足产品需求，因此需要尽可能提供简单易用效果好的接口给业务方，而不是提供高性能的接口给业务方。</li>
<li>苹果平台的性能非常之棒，正常情况下很少会出现由于性能不够导致的用户体验问题。</li>
<li>苹果平台的优化手段相对有限，甚至于有些时候即便动用了无所不用其极的手段乃至不择手段牺牲了稳定性，性能提高很有可能也只不过是100ms到90ms的差距。10%的性能提升对于服务端来说很不错了，因为服务端动不动就是几十万上百万的访问量，几十万上百万个10ms是很可观的。但是对于客户端的用户来说，他无法感知这10ms的差别，如果从10s优化成9s用户还是有一定感知的，但是100ms变90ms，我觉得吧，还是别折腾了。<br>但是！不重要不代表用不着去做，关于性能优化的东西，我会对应放到各系列文章里面去。比如网络层优化，那就会在网络层方案的那篇文章里面去写，对应每层架构都有每层架构的不同优化方案，我都会在各自文章里面一一细说。</li>
</ul>
<p>&nbsp;</p>
<blockquote>
<p>其实分层这种东西，真没啥技术含量，全凭架构师的经验和素质。<br>&nbsp;</p>
</blockquote>
<h1 id="架构之分层"><a href="#架构之分层" class="headerlink" title="架构之分层"></a>架构之分层</h1><p>我们常见的分层架构，有三层架构的：展现层、业务层、数据层。也有四层架构的：展现层、业务层、网络层、本地数据层。这里说三层、四层，跟TCP/IP所谓的五层或者七层不是同一种概念。再具体说就是：你这个架构在逻辑上是几层那就几层，具体每一层叫什么，做什么，没有特定的规范。这主要是针对模块分类而言的。</p>
<p>也有说MVC架构，MVVM架构的，这种层次划分，主要是针对数据流动的方向而言的。</p>
<p>在实际情况中，针对数据流动方向做的设计和针对模块分类做的设计是会放在一起的，也就是说，一个MVC架构可以是四层：展现层、业务层、网络层、本地数据层。</p>
<p>那么，为什么我要说这个？</p>
<p>大概在五六年前，业界很流行三层架构这个术语。然后各种文档资料漫天的三层架构，并且喜欢把它与MVC放在一起说，MVC三层架构/三层架构MVC，以至于很多人就会认为三层架构就是MVC，MVC就是三层架构。其实不是的。三层架构里面其实没有Controller的概念，而且三层架构描述的侧重点是模块之间的逻辑关系。MVC有Controller的概念，它描述的侧重点在于数据流动方向。</p>
<p>好，为什么流行起来的是三层架构，而不是四层架构或五层架构？</p>
<p>因为所有的模块角色只会有三种：数据管理者、数据加工者、数据展示者，意思也就是，笼统说来，软件只会有三层，每一层扮演一个角色。其他的第四层第五层，一般都是这三层里面的其中之一分出来的，最后都能归纳进这三层的某一层中去，所以用三层架构来描述就比较普遍。</p>
<p>那么我们怎么做分层？</p>
<p>应该如何做分层，不是在做架构的时候一开始就考虑的问题。虽然我们要按照自顶向下的设计方式来设计架构，但是一般情况下不适合直接从三层开始。一般都是先确定所有要解决的问题，先确定都有哪些模块，然后再基于这些模块再往下细化设计。然后再把这些列出来的问题和模块做好分类。分类之后不出意外大多数都是三层。如果发现某一层特别庞大，那就可以再拆开来变成四层，变成五层。</p>
<hr>
<p>举个例子：你要设计一个即时通讯的服务端架构，怎么分层？</p>
<p>记住，不要一上来就把三层架构的规范套上去，这样做是做不出好架构的。</p>
<p>你要先确定都需要解决哪些问题。这里只是举例子，我随意列出一点意思意思就好了：</p>
<ol>
<li>要解决用户登录、退出的问题</li>
<li>解决不同用户间数据交流的问题</li>
<li>解决用户数据存储的问题</li>
<li>如果是多台服务器的集群，就要解决用户连接的寻址问题<br>解决第一个问题需要一个链接管理模块，链接管理模块一般是通过链接池来实现。 解决第二个问题需要有一个数据交换模块，从A接收来的数据要给到B，这个事情由这个模块来做。 解决第三个问题需要有个数据库，如果是服务于大量用户，那么就需要一个缓冲区，只有当需要存储的数据达到一定量时才执行写操作。 解决第四个问题可以有几种解决方案，一个是集群中有那么几台服务器作为寻路服务器，所有寻路的服务交给那几台去做，那么你需要开发一个寻路服务的Daemon。或者用广播方式寻路，但如果寻路频次非常高，会造成集群内部网络负载特别大。这是你要权衡的地方，目前流行的思路是去中心化，那么要解决网络负载的问题，你就可以考虑配置一个缓存。</li>
</ol>
<p>于是我们有了这些模块：</p>
<p>链接管理、数据交换、数据库及其配套模块、寻路模块</p>
<p>做到这里还远远没有结束，你要继续针对这四个模块继续往下细分，直到足够小为止。但是这里只是举例子，所以就不往下深究了。</p>
<p>另外，我要提醒你的是，直到这时，还是跟几层架构毫无关系的。当你把所有模块都找出来之后，就要开始整理你的这些模块，很有可能架构图就是这样：</p>
<p><div></div></p>
<p><pre class="">    链接管理  收发数据                     收发数据<br>        数据交换                       /        \<br>                            \   链接管理        数据交换<br>    寻路服务          ========\                   /  \<br>                    ========/            数据库服务   寻路服务<br>        数据库服务           /<br></pre><br><br>然后这些模块分完之后你看一下图，嗯，1、2、3，一共三层，所以那就是三层架构啦。在这里最消耗脑力最考验架构师功力的地方就在于：找到所有需要的模块, 把模块放在该放的地方</p>
<p>这个例子侧重点在于如何分层，性能优化、数据交互规范和包协议、数据采集等其他一系列必要的东西都没有放进去，但看到这里，相信你应该了解架构师是怎么对待分层问题的了吧？</p>
<blockquote>
<p>对的，答案就是没有分层。所谓的分层都是出架构图之后的事情了。所以你看别的架构师在演讲的时候，上来第一句话差不多都是：”这个架构分为以下几层…”。但考虑分层的问题的时机绝对不是一开始就考虑的。另外，模块一定要把它设计得独立性强，这其实是门艺术活。<br>另外，这虽然是服务端架构，但是思路跟客户端架构是一样的，侧重点不同罢了。之所以不拿客户端架构举例子，是因为这方面的客户端架构苹果已经帮你做好了绝大部分事情，没剩下什么值得说的了。</p>
</blockquote>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>一下子挖了个大坑，在开篇里扯了一些淡。</p>
<p>嗯，干货会在后续的系列文章里面扑面而来的！</p>
<p>&nbsp;</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/10/ios-e4-b8-ad-e9-9b-86-e5-90-88-e9-81-8d-e5-8e-86-e6-96-b9-e6-b3-95-e7-9a-84-e6-af-94-e8-be-83-e5-92-8c-e6-8e-a8-e8-8d-90/" itemprop="url">
                  ios中集合遍历方法的比较和推荐
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-10T10:37:20+08:00" content="2015-11-10">
              2015-11-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>集合的遍历操作是开发中最常见的操作之一，从C语言经典的for循环到利用多核cpu的优势进行遍历，开发中ios有若干集合遍历方法，本文通过研究和测试比较了各个操作方法的效率和优略势，并总结几个使用集合遍历时的小技巧。</p>
<h1 id="ios中常用的遍历运算方法"><a href="#ios中常用的遍历运算方法" class="headerlink" title="ios中常用的遍历运算方法"></a>ios中常用的遍历运算方法</h1><p>遍历的目的是获取集合中的某个对象或执行某个操作，所以能满足这个条件的方法都可以作为备选：</p>
<ul>
<li>经典for循环</li>
<li>for in (NSFastEnumeration)，若不熟悉可以参考<a href="http://nshipster.com/enumerators/" target="_blank" rel="external">《nshipster介绍NSFastEnumeration的文章》</a></li>
<li>makeObjectsPerformSelector</li>
<li>kvc集合运算符</li>
<li>enumerateObjectsUsingBlock</li>
<li>enumerateObjectsWithOptions(NSEnumerationConcurrent)</li>
<li>dispatch_apply</li>
</ul>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验条件"><a href="#实验条件" class="headerlink" title="实验条件"></a>实验条件</h2><p>测试类如下：</p>
<figure class="highlight"><br><pre class="lang:objc decode:true">@interface Sark : NSObject<br>@property (nonatomic) NSInteger number;<br>- (void)doSomethingSlow; // sleep(0.01)<br>@end</pre><br></figure>实验从两个方面来评价：<br><br>1. 分别使用有100个对象和1000000个对象的NSArray，只取对象，不执行操作，测试遍历速度<br>2. 使用有100个对象的NSArray遍历执行doSomethingSlow方法，测试遍历中多任务运行速度<br><br>实验使用CFAbsoluteTimeGetCurrent()记录时间戳来计算运行时间，单位秒。<br>运行在iphone5真机（双核cpu）<br><br>## 实验数据<br><br>100对象遍历操作：<br><br><figure class="highlight"><br><pre class="lang:objc decode:true">经典for循环 - 0.001355<br>for in (NSFastEnumeration) - 0.002308<br>makeObjectsPerformSelector - 0.001120<br>kvc集合运算符(@sum.number) - 0.004272<br>enumerateObjectsUsingBlock - 0.001145<br>enumerateObjectsWithOptions(NSEnumerationConcurrent) - 0.001605<br>dispatch_apply(Concurrent) - 0.001380</pre><br></figure>1000000对象遍历操作：<br><br><figure class="highlight"><br><pre class="lang:objc decode:true">经典for循环 - 1.246721<br>for in (NSFastEnumeration) - 0.025955<br>makeObjectsPerformSelector - 0.068234<br>kvc集合运算符(@sum.number) - 21.677246<br>enumerateObjectsUsingBlock - 0.586034<br>enumerateObjectsWithOptions(NSEnumerationConcurrent) - 0.722548<br>dispatch_apply(Concurrent) - 0.607100</pre><br></figure>100对象遍历执行一个很费时的操作：<br><br><figure class="highlight"><br><pre class="lang:objc decode:true">经典for循环 - 1.106567<br>for in (NSFastEnumeration) - 1.102643<br>makeObjectsPerformSelector - 1.103965<br>kvc集合运算符(@sum.number) - N/A<br>enumerateObjectsUsingBlock - 1.104888<br>enumerateObjectsWithOptions(NSEnumerationConcurrent) - 0.554670<br>dispatch_apply(Concurrent) - 0.554858</pre><br></figure>

<h2 id="值得注意的"><a href="#值得注意的" class="headerlink" title="值得注意的"></a>值得注意的</h2><ul>
<li>对于集合中对象数很多的情况下，for in (NSFastEnumeration)的遍历速度非常之快，但小规模的遍历并不明显（还没普通for循环快）</li>
<li>使用kvc集合运算符运算很大规模的集合时，效率明显下降（100万的数组离谱的21秒多），同时占用了大量内存和cpu</li>
<li>enumerateObjectsWithOptions(NSEnumerationConcurrent)和dispatch_apply(Concurrent)的遍历执行可以利用到多核cpu的优势（实验中在双核cpu上效率基本上x2）</li>
</ul>
<h2 id="个人推荐"><a href="#个人推荐" class="headerlink" title="个人推荐"></a>个人推荐</h2><ul>
<li>再不需要遍历索引时,个人喜欢用for in (NSFastEnumeration).</li>
<li>再需要遍历索引时,个人喜欢用enumerateObjectsUsingBlock或者enumerateObjectsWithOptions</li>
</ul>
<h1 id="遍历实践Tips"><a href="#遍历实践Tips" class="headerlink" title="遍历实践Tips"></a>遍历实践Tips</h1><h2 id="倒序遍历"><a href="#倒序遍历" class="headerlink" title="倒序遍历"></a>倒序遍历</h2><p>NSArray和NSOrderedSet都支持使用reverseObjectEnumerator倒序遍历，如：</p>
<figure class="highlight"><br><pre class="lang:objc decode:true">NSArray <em>strings = @[@”1”, @”2”, @”3”];<br>for (NSString </em>string in [strings reverseObjectEnumerator]) {<br>    NSLog(@”%@”, string);<br>}</pre><br></figure>这个方法只在循环第一次被调用，所以也不必担心循环每次计算的问题。<br><br>同时，使用enumerateObjectsWithOptions:NSEnumerationReverse也可以实现倒序遍历：<br><br><figure class="highlight"><br><pre class="lang:objc decode:true">[array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(Sark <em>sark, NSUInteger idx, BOOL </em>stop) {<br>    [sark doSomething];<br>}];</pre><br></figure>

<h2 id="使用block同时遍历字典key，value"><a href="#使用block同时遍历字典key，value" class="headerlink" title="使用block同时遍历字典key，value"></a>使用block同时遍历字典key，value</h2><p>block版本的字典遍历可以同时取key和value（forin只能取key再手动取value），如：</p>
<figure class="highlight"><br><pre class="lang:objc decode:true">NSDictionary <em>dict = @{@”a”: @”1”, @”b”: @”2”};<br>[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL </em>stop) {<br>    NSLog(@”key: %@, value: %@”, key, obj);<br>}];</pre><br></figure>

<h2 id="对于耗时且顺序无关的遍历，使用并发版本"><a href="#对于耗时且顺序无关的遍历，使用并发版本" class="headerlink" title="对于耗时且顺序无关的遍历，使用并发版本"></a>对于耗时且顺序无关的遍历，使用并发版本</h2><p><figure class="highlight"></figure></p>
<p><pre class="lang:objc decode:true">[array enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(Sark <em>sark, NSUInteger idx, BOOL </em>stop) {<br>    [sark doSomethingSlow];<br>}];</pre><br>遍历执行block会分配在多核cpu上执行（底层很可能就是gcd的并发queue），对于耗时的任务来说是很值得这么做的，而且在以后cpu升级成更多核心后不用改代码也可以享受带来的好处。同时，对于遍历的外部是保持同步的（遍历都完成后才继续执行下一行），猜想内部大概是gcd的dispatch_group或者信号量控制。</p>
<h2 id="代码可读性和效率的权衡"><a href="#代码可读性和效率的权衡" class="headerlink" title="代码可读性和效率的权衡"></a>代码可读性和效率的权衡</h2><p>虽然说上面的测试结果表明，在集合内元素不多时，经典for循环的效率要比forin要高，但是从代码可读性上来看，就远不如forin看着更顺畅；同样的还有kvc的集合运算符，一些内置的操作以keypath的方式声明，相比自己用for循环实现，一行代码就能搞定，清楚明了，还省去了重复工作；在framework中增加了集合遍历的block支持后，对于需要index的遍历再也不需要经典for循环的写法了。</p>
<p>转载:<a href="http://blog.sunnyxx.com/2014/04/30/ios_iterator/" target="_blank" rel="external">sunnyxx的博客</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/06/ios-e4-b8-adurl-e4-b8-ad-e7-89-b9-e6-ae-8a-e5-ad-97-e7-ac-a6-e8-af-b7-e6-b1-82-e4-b8-ba-e7-a9-ba/" itemprop="url">
                  iOS中url中特殊字符请求为空
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-06T18:16:42+08:00" content="2015-11-06">
              2015-11-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目中加载图片时因为图片地址中有特殊字符，导致图片无法加载，错误但写法是：</p>
<p><pre class="lang:objc decode:true">NSString <em>str = [NSString stringWithFormat:@”%@”,@”<a href="http://list.vip.com/557574.html?shop_r=557574&amp;f=ad&amp;ff=72|1|1|1&amp;sche=mocha" target="_blank" rel="external">http://list.vip.com/557574.html?shop_r=557574&amp;f=ad&amp;ff=72|1|1|1&amp;sche=mocha</a>“];<br>NSURL </em>url = [NSURL URLWithString:str];<br>[self.testUIImageView setImageWithURL:url];</pre><br>正确但写法</p>
<p><pre class="lang:objc decode:true ">NSString <em>str = [NSString stringWithFormat:@”%@”,@”<a href="http://list.vip.com/557574.html?shop_r=557574&amp;f=ad&amp;ff=72|1|1|1&amp;sche=mocha" target="_blank" rel="external">http://list.vip.com/557574.html?shop_r=557574&amp;f=ad&amp;ff=72|1|1|1&amp;sche=mocha</a>“];<br>NSString </em>urlStr = [str stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];<br>NSURL *url = [NSURL URLWithString:urlStr];<br>[self.testUIImageView setImageWithURL:url];</pre><br>&nbsp;</p>
<p>错误分析过程，当把urlString不经过处理直接使用的时候发现，传入setImageWithURL的url是null,而把url直接放入浏览器发现url变成了<a href="http://list.vip.com/557574.html?shop_r=557574&amp;f=ad&amp;ff=72|1|1|1&amp;sche=mocha" target="_blank" rel="external">http://list.vip.com/557574.html?shop_r=557574&amp;f=ad&amp;ff=72|1|1|1&amp;sche=mocha</a><br>显然URL经过了浏览器的编码处理。所以问题解决办法就很明显了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/04/bmpostscoreview-e6-89-8b-e5-8a-bf-e6-89-93-e5-88-86-e6-8e-a7-e4-bb-b6/" itemprop="url">
                  BMPostScoreView手势打分控件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-04T17:23:14+08:00" content="2015-11-04">
              2015-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/未分类/" itemprop="url" rel="index">
                    <span itemprop="name">未分类</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://birdmichael.com/wp-content/uploads/2015/11/QQ20151104-1.png" target="_blank" rel="external"><img src="http://birdmichael.com/wp-content/uploads/2015/11/QQ20151104-1.png" alt="QQ20151104-1"></a></p>
<p>首先感谢抹茶美妆</p>
<p>这是一个手势打分的小控件,百分百贴合.</p>
<p><strong>需求</strong></p>
<ul>
<li>需求是0分不能回退到100.99.98</li>
<li>100分以后不能进到0.1.2.3</li>
<li>但是100分以后可以回退到99.98<br>Github地址:<a href="https://github.com/birdmichael/BMGestureScoring" target="_blank" rel="external">https://github.com/birdmichael/BMGestureScoring</a></li>
</ul>
<p>实际效果图</p>
<p><a href="http://birdmichael.com/wp-content/uploads/2015/11/QQ20151104-2.png" target="_blank" rel="external"><img src="http://birdmichael.com/wp-content/uploads/2015/11/QQ20151104-2.png" alt="QQ20151104-2"></a></p>
<p>开源效果图</p>
<p><a href="http://birdmichael.com/wp-content/uploads/2015/11/QQ20151104-3.png" target="_blank" rel="external"><img src="http://birdmichael.com/wp-content/uploads/2015/11/QQ20151104-3.png" alt="QQ20151104-3"></a></p>
<p><a href="http://birdmichael.com/wp-content/uploads/2015/11/QQ20151104-4.png" target="_blank" rel="external"><img src="http://birdmichael.com/wp-content/uploads/2015/11/QQ20151104-4.png" alt="QQ20151104-4"></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/30/ios-e5-94-af-e4-b8-80-e6-a0-87-e7-a4-ba-e7-ac-a6-e5-bc-95-e5-af-bc/" itemprop="url">
                  iOS唯一标示符引导
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-30T10:45:47+08:00" content="2015-10-30">
              2015-10-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IOS/" itemprop="url" rel="index">
                    <span itemprop="name">IOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><div>在2013年3月21日苹果已经通知开发者，从2013年5月1日起，<a href="https://developer.apple.com/news/index.php?id=3212013a" target="_blank" rel="external"><em><strong>访问UIDID的应用将不再能通过审核</strong></em></a>，替代的方案是开发者应该使用“在iOS 6中介绍的Vendor或Advertising标示符”。</div><br>unique Identifier即将退出，苹果给了我们Vendor和Advertising identifier两个选择，但应该用哪一个？文档并没有给出确切答案，具体使用哪个完全由你根据自己app的目的来决定。下面我将列出iOS中目前支持的，以及被废弃的唯一标示符方法，并对其做出相应的解释，希望可以帮你做出正确的确定。</p>
<p>&nbsp;</p>
<p><strong>CFUUID</strong><br>从iOS2.0开始，CFUUID就已经出现了。它是CoreFoundatio包的一部分，因此API属于C语言风格。<a href="https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFUUIDRef/Reference/reference.html#//apple_ref/c/func/CFUUIDCreate" target="_blank" rel="external"><em><strong>CFUUIDCreate </strong></em></a>方法用来创建CFUUIDRef，并且可以获得一个相应的NSString，如下代码：</p>
<p>CFUUIDRef cfuuid = CFUUIDCreate(kCFAllocatorDefault);NSString <em>cfuuidString = (NSString</em>)CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, cfuuid));</p>
<p>&nbsp;</p>
<p>获得的这个CFUUID值系统并没有存储。每次调用CFUUIDCreate，系统都会返回一个新的唯一标示符。如果你希望存储这个标示符，那么需要自己将其存储到NSUserDefaults, Keychain, Pasteboard或其它地方。</p>
<p>&nbsp;</p>
<p><strong>NSUUID</strong><br><a href="http://developer.apple.com/library/ios/#documentation/Foundation/Reference/NSUUID_Class/Reference/Reference.html" target="_blank" rel="external"><em><strong>NSUUID</strong></em></a>在iOS 6中才出现，这跟CFUUID几乎完全一样，只不过它是Objective-C接口。+ (id)UUID 是一个类方法，调用该方法可以获得一个UUID。通过下面的代码可以获得一个UUID字符串：</p>
<p>NSString *uuid = [[NSUUID UUID] UUIDString];</p>
<p>&nbsp;</p>
<p>跟CFUUID一样，这个值系统也不会存储，每次调用的时候都会获得一个新的唯一标示符。如果要存储的话，你需要自己存储。在我读取NSUUID时，注意到获取到的这个值跟CFUUID完全一样（不过也可能不一样）：</p>
<p>示例: 68753A44-4D6F-1226-9C60-0050E4C00067</p>
<p>&nbsp;</p>
<p><strong>广告标示符（IDFA-identifierForIdentifier）</strong><br>这是iOS 6中另外一个新的方法，<a href="https://developer.apple.com/library/ios/#documentation/AdSupport/Reference/ASIdentifierManager_Ref/ASIdentifierManager.html#//apple_ref/occ/instp/ASIdentifierManager/advertisingIdentifier" target="_blank" rel="external"><em><strong>advertisingIdentifier</strong></em></a>是新框架AdSupport.framework的一部分。ASIdentifierManager单例提供了一个方法advertisingIdentifier，通过调用该方法会返回一个上面提到的NSUUID实例。</p>
<p>NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];</p>
<p>&nbsp;</p>
<p>跟CFUUID和NSUUID不一样，广告标示符是由系统存储着的。不过即使这是由系统存储的，但是有几种情况下，会重新生成广告标示符。如果用户完全重置系统（(设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私) ，这个广告标示符会重新生成。另外如果用户明确的还原广告(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符) ，那么广告标示符也会重新生成。关于广告标示符的还原，有一点需要注意：如果程序在后台运行，此时用户“还原广告标示符”，然后再回到程序中，此时获取广告标示符并不会立即获得还原后的标示符。必须要终止程序，然后再重新启动程序，才能获得还原后的广告标示符。之所以会这样，我猜测是由于ASIdentifierManager是一个单例。<br>针对广告标示符用户有一个可控的开关“限制广告跟踪”。<a href="http://www.doubleencore.com/2013/04/what-apples-limit-ad-tracking-feature-actually-means-to-users/" target="_blank" rel="external"><em><strong>Nick Arnott的文章中</strong></em></a>已经指出了。将这个开关打开，实际上什么也没有做，不过这是希望限制你访问广告标示符。这个开关是一个简单的boolean标志，当将广告标示符发到任意的服务器端时，你最好判断一下这个值，然后再做决定。</p>
<p>示例: 1E2DFA89-496A-47FD-9941-DF1FC4E6484A</p>
<p>&nbsp;</p>
<p><strong>Vindor标示符 (IDFV-identifierForVendor)</strong><br>这种叫法也是在iOS 6中新增的，不过获取这个IDFV的新方法被添加在已有的UIDevice类中。跟advertisingIdentifier一样，该方法返回的是一个NSUUID对象。</p>
<p>NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString];</p>
<p>&nbsp;</p>
<p>苹果官方的文档中对identifierForVendor有如下这样的一段描述 ：</p>
<p><em>The value of this property is the same for apps that come from the same vendor running on the same device. A different value is returned for apps on the same device that come from different vendors, and for apps on different devices regardless of vendor.</em></p>
<p>&nbsp;</p>
<p>如果满足这样的条件，那么获取到的这个属性值就不会变：相同的一个程序里面-相同的vindor-相同的设备。如果是这样的情况，那么这个值是不会相同的：相同的程序-相同的设备-不同的vindor，或者是相同的程序-不同的设备-无论是否相同的vindor。</p>
<p>&nbsp;</p>
<p>看完上面的内容，我有这样的一个疑问“vendor是什么”。我首先想到的是苹果开发者账号。但事实证明这是错误的。接着我想可能是有一个AppIdentifierPrefix东西，跟钥匙串访问一样，可以在多个程序间共享。同样，这个想法也是的。最后证明，vendor非常简单：一个Vendor是CFBundleIdentifier（反转DNS格式）的前两部分。例如，com.doubleencore.app1 和 com.doubleencore.app2 得到的identifierForVendor是相同的，因为它们的CFBundleIdentifier 前两部分是相同的。不过这样获得的identifierForVendor则完全不同：com.massivelyoverrated 或 net.doubleencore。</p>
<p>&nbsp;</p>
<p>在这里，还需要注意的一点就是：如果用户卸载了同一个vendor对应的所有程序，然后在重新安装同一个vendor提供的程序，此时identifierForVendor会被重置。</p>
<p>示例: 599F9C00-92DC-4B5C-9464-7971F01F8370<br><strong>UDID</strong><br>在之前的版本中是可用的，但是在iOS5以及之后的版本中，以及被弃用了。虽然，这个UDID用得很广泛，但是，不得不说的是，它在慢慢的远离开发者，不能在考虑使用UDID了。至于这个标示符是转为私有方法，或者完全从以后的iOS版本中移除，还有待观察。不过，这个UDID在部署企业级签名程序时，非常方便。获取UDID的方法如下：</p>
<p>NSString *udid = [[UIDevice currentDevice] uniqueIdentifier];</p>
<p>示例: bb4d786633053a0b9c0da20d54ea7e38e8776da4</p>
<p>&nbsp;</p>
<p><strong>OpenUDID</strong><br>在iOS 5发布时，uniqueIdentifier被弃用了，这引起了广大开发者需要寻找一个可以替代UDID，并且不受苹果控制的方案。由此<a href="https://github.com/ylechelle/OpenUDID" target="_blank" rel="external"><em><strong>OpenUDID</strong></em></a>成为了当时使用最广泛的开源UDID替代方案。OpenUDID在工程中实现起来非常简单，并且还支持一系列的广告提供商。</p>
<p>NSString *openUDID = [OpenUDID value];</p>
<p>&nbsp;</p>
<p>OpenUDID利用了一个非常巧妙的方法在不同程序间存储标示符 — 在粘贴板中用了一个特殊的名称来存储标示符。通过这种方法，别的程序（同样使用了OpenUDID）知道去什么地方获取已经生成的标示符（而不用再生成一个新的）。</p>
<p>&nbsp;</p>
<p>之前已经提到过，在将来，苹果将开始强制使用advertisingIdentifier 或identifierForVendor。如果这一天到来的话，即使OpenUDID看起来是非常不错的选择，但是你可能不得不过渡到苹果推出的方法。</p>
<p>示例: 0d943976b24c85900c764dd9f75ce054dc5986ff</p>
<p>&nbsp;</p>
<p>总结<br>希望上面的信息能够帮助你在程序使用选择正确的唯一标示符。在这里，我创建了一个小的<a href="https://github.com/doubleencore/DEUID" target="_blank" rel="external"><em><strong>唯一标示符测试程序</strong></em></a>，你可以运行该程序，并查看一下显示的内容（包括上面提到的所有标示符）。另外，下面有两个表，表中描述了两个内容：在iOS中的可用性，以及什么时候可以获得重置的标示符。</p>
<p><div><a href="http://birdmichael.com/wp-content/uploads/2015/10/4196_130422094510_1.png" target="_blank" rel="external"><img src="http://birdmichael.com/wp-content/uploads/2015/10/4196_130422094510_1.png" alt="4196_130422094510_1"></a><br></div></p>
<ul>
<li>程序必须重启才能看到改变的效果。<br>** 删除了所有相同vendor提供的程序，才能看到改变的值。</li>
</ul>
<p>来源:<a href="http://www.cocoachina.com/industry/20130422/6040.html" target="_blank" rel="external">http://www.cocoachina.com/industry/20130422/6040.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/27/ios-e5-bc-80-e5-8f-91-e4-bd-bf-e7-94-a8weak-e5-ba-94-e8-af-a5-e4-bc-98-e5-85-88-e4-ba-8estrong-e5-8e-9f-e5-9b-a0/" itemprop="url">
                  iOS开发使用strong应该优先于weak原因
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-27T16:08:25+08:00" content="2015-10-27">
              2015-10-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><div class="zm-editable-content clearfix">最近来到新公司产生了控件使用strong&amp;weak问题的讨论。项目中所有控件包括咨询的很多人都习惯的使用strong，并且有Storyboards拖得控件使用weak,代码创建的使用strong的习惯。而我一直控件使用的weak。所以产生了讨论。</div>

<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>正如大家知道的，如果一个对象没有被强引用就会被自动释放，那么我们还未什么要在控件使用weak？控件不会被释放？控件还可以正常显示？</p>
<p>首先我们大致的分三种情况</p>
<ol>
<li>从storyboard或者xib创建</li>
<li>手动创建声明为weak</li>
<li>手动创建声明为strong</li>
</ol>
<h3 id="从storyboard或者xib创建"><a href="#从storyboard或者xib创建" class="headerlink" title="从storyboard或者xib创建"></a>从storyboard或者xib创建</h3><div><br><div class="zm-editable-content clearfix">当一个控件被放在View上时，就已经存在了如下的一个拥有关系：<strong>UIViewController-&gt;UIView-&gt;subView-&gt;（控件）</strong><br>然后你为这个控件声明一个weak属性</div><br><div class="zm-editable-content clearfix"><br><pre class="lang:objc decode:true">@property(nonatomic,weak) IBOOutlet UIButton *btn;</pre><br></div><br><div class="zm-editable-content clearfix"><br><br>相当于storyboard或者xib对这个控件是强引用，你声明的属性对它是弱引用。<br><br></div><br></div>

<h3 id="手动创建并声明strong"><a href="#手动创建并声明strong" class="headerlink" title="手动创建并声明strong"></a>手动创建并声明strong</h3><p><pre class="lang:objc decode:true ">@property(nonatomic,strong) UIButton *btn;</pre></p>
<div class="zm-editable-content clearfix"><br><div><br><br>那么你在实现这个控件时只需这样：<br><div class="highlight"><br><br>    _btn = [[UIButton alloc]init];<br>    [self.view addSubview:_btn]`<br>    </div><br>    </div><br>    </div>

<pre><code>### 手动创建并申明为weak

&lt;div class=&quot;highlight&quot;&gt;
&lt;pre&gt;`@property(nonatomic,weak) UIButton *btn;
`&lt;/pre&gt;
&lt;/div&gt;
那么你在实现这个控件时需要这样：
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre&gt;`UIButton *button = [[UIButton alloc]init];
_btn = button;
[self.view addSubview:_btn];
</code></pre><p></p>
<div>其实不管声明的属性是强引用还是弱引用，在控制器消失的时候，这个属性消失，View消失，subViews消失，控件也就消失了。</div><br>也许你会觉得似乎用strong更简单。<br><br>## 说明<br><br>IBOutlet的属性一般可以设为weak是因为它已经被view引用了，除非view被释放，否则IBOutlet的属性也不会被释放，另外IBOutlet属性的生命周期和view应该是一致的，所以IBOutlet属性一般设为weak。<br><div><br><div class="zm-editable-content clearfix">可参考如下:<br>From a practical perspective, in iOS and OS X outlets should be defined as declared properties. Outlets should generally be weak, except for those from File’s Owner to top-level objects in a nib file (or, in iOS, a storyboard scene) which should be strong. Outlets that you create will therefore typically be weak by default, because:<br><br><em>   Outlets that you create to, for example, subviews of a view controller’s view or a window controller’s window, are arbitrary references between objects that do not imply ownership.
</em>   The strong outlets are frequently specified by framework classes (for example, UIViewController’s view outlet, or NSWindowController’s window outlet).<br>简单的说，如果IBOutlet对象是nib/sb scene的拥有者（File’s owner）所持有的对象，那么很显然拥有者必须“拥有”对象的指针，因此属性应设置为strong。而其他的IBOutlet对象的属性需要设置为weak，因为拥有者并不需要“拥有”他们的指针。举例来说，UIViewController的view属性是strong，因为controller要直接拥有view。而添加到view上的subviews，作为IBOutlet只需要设置为weak就可以了，因为他们不是controller直接拥有的。直接拥有subviews的是controller的view，ARC会帮助管理内存。<br><br>紧接着，<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW8" target="_blank" rel="external">文档里</a>又提到：<br>&gt; Outlets should be changed to strong when the outlet should be considered to own the referenced object:<br>&gt;<br>&gt;<br>&gt; <em>   As indicated previously, this is often the case with File’s Owner—top level objects in a nib file are frequently considered to be owned by the File’s Owner.<br>&gt; </em>   You may in some situations need an object from a nib file to exist outside of its original container. For example, you might have an outlet for a view that can be temporarily removed from its initial view hierarchy and must therefore be maintained independently.<br>第一种情形前面已经解释过了，对于第二种，通俗点将，就是controller需要直接控制某一个subview并且将subview添加到其他的view tree上去。<br><br>单纯从ARC的角度思考，用weak也是很显然的：因为subview添加到view上时，view会“拥有”subview。当然，给IBOutlet属性设置为strong也没有错，“纠结谁对谁错“的问题可能需要上升到模式或者编码习惯的问题，已经超出本文的范围。<br><br>## 理解<br><br>首先，控件的父（( view.superview )）已经 “强” 的抓着他，所以你只需要 “弱弱” 的看着他就好。因为 “<br><br><span class="s1">addSubview</span>“的原因。 并且当控件从 父 上移除，就自动销毁，逻辑上也是正确的。<br><br>另外，如果你需要控件再View的SuperView里面remove以后还是继续存在（重复添加），就好比你不管控件的父（( view.superview )）已经 “强” 的抓着他，反正你要 “强强”的抓住他，需要控件的时候就立马把他抓过来用，这个时候你就需要用强。<br>&gt; 这个只是个人理解观点，如果有不妥还请指正。<br><br>## <strong>Strong 引用的 IBOutlet</strong><br><br>Apple已经对Xib和Storyboard文件做了很多优化。并且由于这些优化，你现在可以将IBOutlet定义为strong，而不是weak。Apple曾在上一届的WWDC上指出这一点，因此让我们来看一下其中的更多细节。你可以从 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html" target="_blank" rel="external">这个文档</a> 中找到管理Nib文件中对象生命周期的章节：<br><br>Outlet一般来说应该为weak，除了在nib文件 ( 或者iOS中，storyboard scene) 中的File’s Owner的顶级对象，这个对象可以是strong。你创建的Outlets应该为weak，原因如下：<br><br><em>   你创建的一个 view controller 视图的子视图或者 window controller 窗体视图的 Outlets，是对象之间的弱引用，不应该有依赖关系。
</em>   strong的outlet通常是特殊的framework类（如：UIViewController 视图的 outlet，或者 NSWindowController 视窗的 outlet）。<br>正如这个段落所解释的一样，view controller视图的子视图 outlet应该为 weak，因为这个视图已经被nib文件的顶级对象所拥有了。然而，当一个Outlet被定义为weak指针时，ARC会在编译期间调用以下函数：<br><div><br><div id="highlighter_591122" class="syntaxhighlighter js"><br><pre class="lang:objc decode:true">id objc_storeWeak(id <em>object, id value);</em></pre><br></div><br></div><br>这个函数把对象的值作为key，并把它添加到table中。这个table被称为weak table。ARC使用这个table去存储应用中的所有的weak指针。现在，当对象被deallocated时，ARC将会指向weak table并且将weak引用置为nil。同时，ARC将会调用：<br><div><br><div id="highlighter_804541" class="syntaxhighlighter js"><br><pre class="lang:objc decode:true">void objc_destroyWeak(id  object);</pre><br></div><br></div><br>紧接着，注销这个对象并再次调用objc_destroyWeak：<br><div><br><div id="highlighter_927092" class="syntaxhighlighter js"><br><pre class="lang:objc decode:true">objc_storeWeak(id *object, nil);</pre><br></div><br></div><br>这种weak引用关联的生命周期是strong引用的2-3倍。所以，通过避免简单地定义outlets为strong，使用弱引用是一种运行期间的通用做法。<br><br>我想这个决策与已废弃的viewDidUnload方法有关。直到iOS 5，这个方法被用于清空在低内存环境下的视图。正如文档中解释的那样：<br><br>在iOS 5之前，当发生低内存警告或者当前view controller的视图不被需要时，在视图被释放之后，系统会选择性地调用这个方法。这个方法让你可以进行最后的清理工作。如果你的视图存储了视图或者其子视图的单独引用，你应该使用这个方法去释放这些引用。<br><br>在那时，定义一个属性为weak是有意义的，因为这就不用在viewDidUnload额外地释放对象。但是在iOS 9中，我相信我们已经有足够的时间去避免使用这个方法。因此，在IBOutlets定义weak是没意义的。<br><br>来源：<a href="http://www.cocoachina.com/ios/20151026/13868.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20151026/13868.html</a><br><br>## 最新理解<br><br>所以最新的建议是：都用strong！<br><br></div><br></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/07/lazy-fix-uitableviewcell-imageview/" itemprop="url">
                  偷懒固定UITableViewCell 中的 imageView 大小
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-07T04:09:07+08:00" content="2015-10-07">
              2015-10-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/未分类/" itemprop="url" rel="index">
                    <span itemprop="name">未分类</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很多页面其实就是这种展示结果,通常需要imageView,textLabel,detailTextlabel,而UITableViewCell本身提供了方便的自动布局(当有图片和没图片时,textLabel和detailLabel的位置会左右自动调整). 但是图片的大小却是没有办法固定的(直接设置imageView.frame是无法固定imageView的大小的),那么一般来说解决这个问题的办法有两种:</p>
<ul>
<li>固定显示图片的大小(包括PlaceHolder)</li>
<li>自定义tableViewCell,添加自定义的imageView,textLabel和detailTextLabel<br>这两种方式都可以解决这个问题,但是这两种方式其实都挺麻烦的,能否直接固定imageView的大小呢? 方法是有的,只需要重载layoutSubviews即可</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><pre class="lang:objc decode:true">//自定义一个Cell<br>@interface MMCell : UITableViewCell</pre></p>
<p>@end</p>
<p>@implementation MMCell</p>
<p>//重载layoutSubviews</p>
<ul>
<li>(void)layoutSubviews<br>{<br>  UIImage *img = self.imageView.image;<br>  self.imageView.image = [UIImage imageName:@”res/PlaceHolder.png”];<br>  [super layoutSubviews];<br>  self.imageView.image = img;<br>}</li>
</ul>
<p>@end<br>&nbsp;</p>
<p>这样,我们只要使用MMCell就可以固定imageView的大小了,且大小为PlaceHolder.png的大小(一般来说这种页面都会使用一个PlaceHolder.png来显示默认图片).</p>
<p>原理是在UItableVeiw的layoutSubviews调用时,会根据imageView.image的大小来调整imageView, textLabel, detailTextLabel的位置,在此之前我们先将imageView.image设置为PlaceHolder.png图片,等待重新布局完后再将原本的图片设置回去就可以了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="BirdMichael" />
          <p class="site-author-name" itemprop="name">BirdMichael</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">59</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">80</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BirdMichael</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
